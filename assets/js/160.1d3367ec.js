(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{605:function(p,e,a){"use strict";a.r(e);var n=a(3),_=Object(n.a)({},(function(){var p=this,e=p._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":p.$parent.slotKey}},[e("p",[p._v("Pnpm 本质上就是一个包管理器，这一点跟 npm/yarn 没有区别，但它作为杀手锏的两个优势在于")]),p._v(" "),e("h2",{attrs:{id:"更快、更小"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更快、更小"}},[p._v("#")]),p._v(" 更快、更小")]),p._v(" "),e("ul",[e("li",[e("p",[p._v("npm3之前，node_modules采用循环链式依赖的方式进行安装，由此产生的问题："),e("code",[p._v("依赖链路过长，大量重复安装的依赖包")])])]),p._v(" "),e("li",[e("p",[p._v("为了解决以上问题，npm3+和yarn 采用了拍平 node_modules 的方式进行安装，拍平后依赖链路不再嵌套，不会安装重复的包，因此产生的新问题，"),e("code",[p._v("幽灵依赖")])])]),p._v(" "),e("li",[e("p",[p._v("pnpm：")])]),p._v(" "),e("li",[e("p",[p._v("装过的包都通过 hard links 存储在磁盘的 .pnpm-store 文件夹内，所有项目共用，相同的包直接复用")])]),p._v(" "),e("li",[e("p",[p._v("不采用拍平的方式，绝不会下载重复的包")])]),p._v(" "),e("li",[e("p",[p._v("当更新一个包时，如果原版本有100个文件，新版本只新增了1个文件，pnpm不会重新下载101个文件，而只是下载新增的1个文件")])])]),p._v(" "),e("h2",{attrs:{id:"幽灵依赖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#幽灵依赖"}},[p._v("#")]),p._v(" 幽灵依赖")]),p._v(" "),e("p",[p._v("幽灵依赖，即某个包并没有在 package.json 中声明依赖，却能在项目中导入使用")]),p._v(" "),e("p",[p._v("如果使用 npm/yarn 安装依赖， node_modules 下将会同时有 packageA 和 packageB，且 project 中可直接 import packageB；某天 packageA 不再依赖 packageB ，project使用packageB这种做法将会报错")]),p._v(" "),e("p",[p._v("使用 pnpm ，node_modules不再拍平，将无法再使用幽灵依赖")]),p._v(" "),e("p",[p._v("在pnpm中，每个workspace下都有自己的node_modules，里面只能访问到在 package.json 里显示声明的 依赖包，而依赖包软链接到 全局node_modules下对应版本的 依赖包，没有任何一个包会安装多次")]),p._v(" "),e("p",[p._v("ps：pnpm默认是不拍平的，这能解决【幽灵依赖】，如果想要继续使用拍平的方式，也支持配置.npmrc hoist = true")])])}),[],!1,null,null,null);e.default=_.exports}}]);