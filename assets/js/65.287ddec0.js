(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{514:function(v,_,l){"use strict";l.r(_);var e=l(3),i=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("ul",[_("li",[v._v("事件缓存：将事件缓存，可以理解为变成静态的了")]),v._v(" "),_("li",[v._v("添加静态标记：Vue2 是全量 Diff，Vue3 是静态标记 + 非全量 Diff")]),v._v(" "),_("li",[v._v("静态提升：创建静态节点时保存，后续直接复用")]),v._v(" "),_("li",[v._v("使用最长递增子序列优化了对比流程")])]),v._v(" "),_("h2",{attrs:{id:"比对子节点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#比对子节点"}},[v._v("#")]),v._v(" 比对子节点")]),v._v(" "),_("p",[v._v("在 Vue2 里 updateChildren 会进行")]),v._v(" "),_("ul",[_("li",[v._v("头和头比")]),v._v(" "),_("li",[v._v("尾和尾比")]),v._v(" "),_("li",[v._v("头和尾比")]),v._v(" "),_("li",[v._v("尾和头比")]),v._v(" "),_("li",[v._v("都没有命中的对比")])]),v._v(" "),_("p",[v._v("在 Vue3 里 patchKeyedChildren 为")]),v._v(" "),_("ul",[_("li",[v._v("头和头比")]),v._v(" "),_("li",[v._v("尾和尾比")]),v._v(" "),_("li",[v._v("基于最长递增子序列进行移动/添加/删除")])]),v._v(" "),_("p",[v._v("比如")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("老的 children："),_("code",[v._v("[ a, b, c, d, e, f, g ]")])])]),v._v(" "),_("li",[_("p",[v._v("新的 children："),_("code",[v._v("[ a, b, f, c, d, e, h, g ]")])])]),v._v(" "),_("li",[_("p",[v._v("先进行头和头比，发现不同就结束循环，得到 [ a, b ]")])]),v._v(" "),_("li",[_("p",[v._v("再进行尾和尾比，发现不同就结束循环，得到 [ g ]")])]),v._v(" "),_("li",[_("p",[v._v("再保存没有比较过的节点 [ f, c, d, e, h ]，并通过 newIndexToOldIndexMap 拿到在数组里对应的下标，生成数组 [ 5, 2, 3, 4, -1 ]，-1 是老数组里没有的就说明是新增")])]),v._v(" "),_("li",[_("p",[v._v("然后再拿取出数组里的最长递增子序列，也就是 [ 2, 3, 4 ] 对应的节点 [ c, d, e ]")])]),v._v(" "),_("li",[_("p",[v._v("然后只需要把其他剩余的节点，基于 [ c, d, e ] 的位置进行移动/新增/删除就可以了")])])]),v._v(" "),_("p",[v._v("使用最长递增子序列可以最大程度的减少 DOM 的移动，达到最少的 DOM 操作")])])}),[],!1,null,null,null);_.default=i.exports}}]);