(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{522:function(v,_,t){"use strict";t.r(_);var e=t(3),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("ul",[_("li",[v._v("根据html生成dom树")]),v._v(" "),_("li",[v._v("然后根据css得到节点的计算样式（节点的坐标和占用区域）")]),v._v(" "),_("li",[v._v("借助主线程遍历dom树和计算好的样式生成layout tree（布局树）,")]),v._v(" "),_("li",[v._v("遍历layout tree（布局树）生成绘制顺序表，然后主线程将layout tree和绘制顺序信息传递给合成器线程，")]),v._v(" "),_("li",[v._v("合成器线程按规则进行分图层，切割图层生成图块信息")]),v._v(" "),_("li",[v._v("将图块信息传递给栅格线程进行栅格完毕后，再返给合成器线程，生成合成器帧")]),v._v(" "),_("li",[v._v("合成器线程将合成器帧通过IPC传递给浏览器进程，浏览器进程将合成器帧传给GPU进行渲染，结束")])]),v._v(" "),_("h3",{attrs:{id:"构建dom树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构建dom树"}},[v._v("#")]),v._v(" 构建DOM树")]),v._v(" "),_("p",[v._v("输入：我们的html结构")]),v._v(" "),_("p",[v._v("处理：将html结构的文本转换为浏览器可识别的dom树。")]),v._v(" "),_("p",[v._v("输出：dom树")]),v._v(" "),_("p",[v._v("dom树是什么样的？")]),v._v(" "),_("p",[v._v("在浏览器console中打印一个document这个就是一个dom树、")]),v._v(" "),_("h3",{attrs:{id:"样式计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#样式计算"}},[v._v("#")]),v._v(" 样式计算")]),v._v(" "),_("p",[v._v("我们的dom树有了就需要有样式的计算")]),v._v(" "),_("p",[v._v("输入：我们的样式源，link引入、style标签包的、内嵌的style")]),v._v(" "),_("p",[v._v("处理：接收到这些东西之后将我们写的样式转换为浏览器可以识别的结构-叫做styleSheet")]),v._v(" "),_("p",[v._v("输出：styleSheet")]),v._v(" "),_("p",[v._v("styleSheet是什么样的？")]),v._v(" "),_("p",[v._v("在浏览器console中打印一个document.styleSheet这个就是浏览器识别的样式。")]),v._v(" "),_("h3",{attrs:{id:"布局"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#布局"}},[v._v("#")]),v._v(" 布局")]),v._v(" "),_("p",[v._v("布局是根据dom树和styleSheet计算出元素的几何位置。")]),v._v(" "),_("p",[v._v("输入：dom树和styleSheet。")]),v._v(" "),_("p",[v._v("处理：chrome在布局阶段经历两个步骤：创建布局树和布局计算。")]),v._v(" "),_("p",[v._v("创建布局树，根据dom和styleSheet，不可见的元素会被移除。不包含的布局树里面。")]),v._v(" "),_("p",[v._v("布局计算 通过计算得到每个元素的几何位置")]),v._v(" "),_("p",[v._v("输出：布局树")]),v._v(" "),_("h3",{attrs:{id:"分层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分层"}},[v._v("#")]),v._v(" 分层")]),v._v(" "),_("p",[v._v("页面中有层次结构，还有3D效果，所以这里需要将页面根据层级具体分层。")]),v._v(" "),_("p",[v._v("输入：布局树")]),v._v(" "),_("p",[v._v("处理：提取出其中拥有层叠属性和会出现裁剪的元素，")]),v._v(" "),_("p",[v._v("输出： 图层")]),v._v(" "),_("h3",{attrs:{id:"图层绘制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图层绘制"}},[v._v("#")]),v._v(" 图层绘制")]),v._v(" "),_("p",[v._v("输入：图层")]),v._v(" "),_("p",[v._v("处理：将每个图层拆分为多个绘制指令、绘制顺序列表。")]),v._v(" "),_("p",[v._v("输出：绘制指令列表")]),v._v(" "),_("h3",{attrs:{id:"栅格化操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栅格化操作"}},[v._v("#")]),v._v(" 栅格化操作")]),v._v(" "),_("p",[v._v("什么是栅格化？")]),v._v(" "),_("p",[v._v("是指将图块转换为位图。")]),v._v(" "),_("p",[v._v("输入：绘制指令列表")]),v._v(" "),_("p",[v._v("处理：将绘制指令列表提交给合成线程。按照视口附近的图块来优先生成位图。")]),v._v(" "),_("p",[v._v("输出：位图块")]),v._v(" "),_("h3",{attrs:{id:"合成显示"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#合成显示"}},[v._v("#")]),v._v(" 合成显示")]),v._v(" "),_("p",[v._v("输入：位图块。")]),v._v(" "),_("p",[v._v("处理：合成线程将位图块拿到之后，就会产生一个绘制的指令给到浏览器主线程。")]),v._v(" "),_("p",[v._v("输出：我们的页面、")])])}),[],!1,null,null,null);_.default=a.exports}}]);