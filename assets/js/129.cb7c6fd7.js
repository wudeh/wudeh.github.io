(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{575:function(s,e,t){"use strict";t.r(e);var n=t(3),a=Object(n.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[s._v("一般来说，通常都是在 data 中定义一个变量来存储定时器，在 beforedestroy 时候销毁，但是这种不好，引用尤大的话来说就是：")]),s._v(" "),e("ul",[e("li",[s._v("它需要在这个组件实例中保存这个 timer，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。")]),s._v(" "),e("li",[s._v("我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化的清理我们建立的所有东西。")])]),s._v(" "),e("h3",{attrs:{id:"使用-hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-hook"}},[s._v("#")]),s._v(" 使用 hook")]),s._v(" "),e("p",[s._v("该方法是通过$once这个事件侦听器器在定义完定时器之后的位置来清除定时器。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const timer = setInterval(() =>{                    \n\n    // 某些定时器操作                \n}, 500);            \n// 通过$once来监听定时器，在beforeDestroy钩子可以被清除。\nthis.$once('hook:beforeDestroy', () => {            \n    clearInterval(timer);                                    \n})\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])])])}),[],!1,null,null,null);e.default=a.exports}}]);