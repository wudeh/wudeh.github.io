(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{577:function(e,v,t){"use strict";t.r(v);var _=t(3),r=Object(_.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[e._v("#")]),e._v(" 区别")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("reactive")]),e._v(" API 对传入的 "),v("code",[e._v("target")]),e._v(" 类型有限制，必须是对象或者数组类型，而对于一些基础类型（比如 String、Number、Boolean）是不支持的。")])]),e._v(" "),v("li",[v("p",[e._v("但是有时候从需求上来说，可能我只希望把一个字符串变成响应式，却不得不封装成一个对象，这样使用上多少有一些不方便")])]),e._v(" "),v("li",[v("p",[e._v("我们需要一个基本类型作为响应式，如果用"),v("code",[e._v("reactive")]),e._v("的话就需要"),v("code",[e._v("reactive({value:xxx})")]),e._v("这样传进去")])]),e._v(" "),v("li",[v("p",[e._v("所以"),v("code",[e._v("vue3")]),e._v("就提供了"),v("code",[e._v("ref")]),e._v("这种写法，让你不需要手动包装成对象。所以这也是为什么"),v("code",[e._v("ref")]),e._v("包装的响应式对象需要"),v("code",[e._v(".value")]),e._v("才能拿到值的原因。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("ref")]),e._v("本质上还是"),v("code",[e._v("reactive")])])])]),e._v(" "),v("h2",{attrs:{id:"vue3的响应式原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue3的响应式原理"}},[e._v("#")]),e._v(" Vue3的响应式原理")]),e._v(" "),v("ul",[v("li",[e._v("Vue.js 3.0 在响应式的实现思路和 Vue.js 2.x 差别并不大，主要就是 劫持数据的方式改成用 Proxy 实现 ， 以及收集的依赖由 watcher 实例变成了组件副作用渲染函数 。")]),e._v(" "),v("li",[e._v("由于 Proxy 劫持的是整个对象，所以我们可以检测到任何对对象的修改，弥补了 Object.defineProperty API 的不足。")]),e._v(" "),v("li",[e._v("Object.defineProperty 是在初始化阶段，即定义劫持对象的时候就已经递归执行了，而 Proxy 是在对象属性被访问的时候才递归执行下一步 reactive，这其实是一种延时定义子对象响应式的实现，在性能上会有较大的提升")]),e._v(" "),v("li",[e._v("依赖收集：劫持 "),v("code",[e._v("get")]),e._v(" 函数，通过 "),v("code",[e._v("Reflect.get")]),e._v(" 求值，然后会执行 track 函数收集依赖副作用函数，把当前激活的副作用函数 "),v("code",[e._v("activeEffect")]),e._v(" 作为依赖，然后收集到 "),v("code",[e._v("target")]),e._v(" 相关的 "),v("code",[e._v("depsMap")]),e._v(" 对应 "),v("code",[e._v("key")]),e._v(" 下的依赖集合 "),v("code",[e._v("dep")]),e._v(" 中")]),e._v(" "),v("li",[e._v("通知依赖更新：劫持 "),v("code",[e._v("set")]),e._v(" 函数，主要就做两件事情， 首先通过 Reflect.set 求值 ， 然后通过 trigger 函数派发通知 ，并依据 key 是否存在于 target 上来确定通知类型，即新增还是修改；trigger 函数主要做了四件事情：")]),e._v(" "),v("li",[e._v("通过 targetMap 拿到 target 对应的依赖集合 depsMap；")]),e._v(" "),v("li",[e._v("创建运行的 effects 集合；")]),e._v(" "),v("li",[e._v("根据 key 从 depsMap 中找到对应的 effects 添加到 effects 集合；")]),e._v(" "),v("li",[e._v("遍历 effects 执行相关的副作用函数。")])]),e._v(" "),v("p",[e._v("所以每次 trigger 函数就是根据 target 和 key ，从 targetMap 中找到相关的所有副作用函数遍历执行一遍。")])])}),[],!1,null,null,null);v.default=r.exports}}]);