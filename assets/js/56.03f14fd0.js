(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{503:function(s,e,t){"use strict";t.r(e);var a=t(3),n=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"什么是-requestanimationframe"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-requestanimationframe"}},[s._v("#")]),s._v(" 什么是 requestAnimationFrame")]),s._v(" "),e("p",[s._v("顾名思义，请求动画帧，也称 帧循环")]),s._v(" "),e("h2",{attrs:{id:"怎么用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么用"}},[s._v("#")]),s._v(" 怎么用")]),s._v(" "),e("blockquote",[e("p",[s._v("window.requestAnimationFrame()")])]),s._v(" "),e("ul",[e("li",[s._v("告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function test() {\n    console.log('🚀🚀hello ~ requestAnimationFrame');\n  }\n  requestAnimationFrame(test)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("h2",{attrs:{id:"怎么做动画"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎么做动画"}},[s._v("#")]),s._v(" 怎么做动画")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("说人话：递归调用自己")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("let n = 0\n  function test() {\n    n++\n    console.log(`🚀🚀hello ~ requestAnimationFrame ${n}`);\n    requestAnimationFrame(test)\n  }\n  requestAnimationFrame(test)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("h2",{attrs:{id:"执行频率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行频率"}},[s._v("#")]),s._v(" 执行频率")]),s._v(" "),e("blockquote",[e("p",[s._v("回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与 浏览器屏幕刷新次数 相匹配。")])]),s._v(" "),e("p",[s._v("屏幕刷新频率（次数）： 屏幕每秒出现图像的次数。普通笔记本为60Hz。")]),s._v(" "),e("h2",{attrs:{id:"回调参数-执行时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回调参数-执行时间"}},[s._v("#")]),s._v(" 回调参数(执行时间)")]),s._v(" "),e("blockquote",[e("p",[s._v("回调函数会被传入DOMHighResTimeStamp参数，DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function test(timestamp) {\n    console.log(`🚀🚀hello ~ requestAnimationFrame ${timestamp}`);\n    requestAnimationFrame(test)\n  }\n  requestAnimationFrame(test)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("p",[s._v("此时间精确到三位小数")]),s._v(" "),e("p",[s._v("注意：")]),s._v(" "),e("blockquote",[e("p",[s._v("在同一个帧中的 多个回调函数 ，它们每一个都会接受到一个 相同的时间戳 ，即使在计算上一个回调函数的工作负载期间已经 消耗了一些时间 。该时间戳是一个十进制数，单位毫秒，最小精度为1ms(1000μs)。")])]),s._v(" "),e("p",[s._v("就是浏览器刷新一次的时候，执行所有的 requestAnimationFrame ，并且它们的回调参数是一模一样的。")]),s._v(" "),e("h2",{attrs:{id:"浏览器对它的优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器对它的优化"}},[s._v("#")]),s._v(" 浏览器对它的优化")]),s._v(" "),e("blockquote",[e("p",[s._v("为了提高性能和电池寿命，因此在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页或者隐藏的"),e("iframe",[s._v(" 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。")])])]),s._v(" "),e("p",[s._v("说人话：不在当前页面，不执行 requestAnimationFrame，回来后再执行")]),s._v(" "),e("h2",{attrs:{id:"返回值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#返回值"}},[s._v("#")]),s._v(" 返回值")]),s._v(" "),e("blockquote",[e("p",[s._v("一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。")])]),s._v(" "),e("blockquote",[e("p",[s._v("你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('const beginBtn = document.querySelector("#begin")\n\n  const endBtn = document.querySelector("#end")\n\n  let myRef;\n\n  beginBtn.addEventListener("click", () => {\n    myRef = requestAnimationFrame(test)\n  })\n\n  endBtn.addEventListener("click", () => {\n    cancelAnimationFrame(myRef)\n  })\n\n  function test() {\n    myRef = requestAnimationFrame(test)\n    console.log(\'🚀🚀~ myRef:\', myRef);\n  }\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br")])]),e("p",[s._v("也可以设置条件来终止")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v(" function test(timestamp) {\n    console.log(`🚀🚀hello ~ requestAnimationFrame ${timestamp}`);\n    if (timestamp < 500) {\n      requestAnimationFrame(test)\n    }\n  }\n  requestAnimationFrame(test)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("h2",{attrs:{id:"settimeout-setinterval"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-setinterval"}},[s._v("#")]),s._v(" setTimeout && setInterval")]),s._v(" "),e("p",[s._v("setTimeout 和 setInterval 的问题是，它们不够精确。它们的内在运行机制决定了 时间间隔参数 实际上只是指定了把动画代码添加到 浏览器UI线程队列 中以等待执行的时间。如果队列前面已经加入了其它任务，那动画代码就要等前面的 任务完成后 再执行，并且如果时间间隔过短（小于16.7ms）会造成丢帧，所以就会导致动画可能不会按照预设的去执行，降低用户体验。\nrequestAnimationFrame 采用 浏览器时间间隔 ，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，消耗性能；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个 统一 的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。")]),s._v(" "),e("h2",{attrs:{id:"css3动画"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css3动画"}},[s._v("#")]),s._v(" CSS3动画")]),s._v(" "),e("p",[s._v("CSS3 的transition 和 animation 搭配使用可以说是非常强大了，但是也有做不到的地方，比如说\nscrollTop，另外 CSS3 动画支持的贝塞尔曲线也是有限的。CSS3 做不到的就可以用到 requestAnimationFrame 来解决了")]),s._v(" "),e("h2",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[s._v("#")]),s._v(" 缺点")]),s._v(" "),e("p",[s._v("一般来说，requestAnimationFrame 执行都是很稳定的，但是当浏览器渲染线程被过度占用时这个API调用间隔会非常不稳定，它并不是银弹。")])])}),[],!1,null,null,null);e.default=n.exports}}]);