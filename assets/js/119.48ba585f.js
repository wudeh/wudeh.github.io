(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{567:function(t,n,a){"use strict";a.r(n);var e=a(3),i=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("ul",[n("li",[t._v("使用 "),n("code",[t._v("transform")]),t._v(" 来做动画，避免回流重绘："),n("code",[t._v("transition: transform 300ms linear")]),t._v("；启用GPU加速，避开重排和重绘的环节，将进度条单独提升到一个图层，即不影响其它元素")]),t._v(" "),n("li",[n("code",[t._v("will-change: transform")]),t._v(" ：will-change 能告知浏览器元素会有哪些变化，这样浏览器能在变化之前做好优化准备工作，将一部分复杂计算提前准备好，所以页面的反应更加快速灵敏；最好的使用方式是在动画在要开始的时候加上这个属性，结束移除。如果直接在样式表中显式声明了 will-change 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换 will-change 的值。")]),t._v(" "),n("li",[n("code",[t._v("transitionend")]),t._v(" 函数：监听动画结束之后移除 "),n("code",[t._v("transition")])])]),t._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('node.addEventListener("transitionend", OnTransitionEnd, false);\n')])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br")])]),n("ul",[n("li",[t._v("将要进行动画的动态节点和静态节点，在 HTML 上进行结构分离，避免可能影响静态节点")])]),t._v(" "),n("h2",{attrs:{id:"浏览器渲染的关键步骤"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染的关键步骤"}},[t._v("#")]),t._v(" 浏览器渲染的关键步骤")]),t._v(" "),n("ul",[n("li",[t._v("Styles（样式）: 浏览器计算要应用于元素的样式；")]),t._v(" "),n("li",[t._v("Layout（布局）：浏览器计算每个元素生成形状和位置，比如 width、height、margin、left/top/right/bottom 这些；")]),t._v(" "),n("li",[t._v("Paint（渲染）：浏览器将每个元素的像素填充到图层中；")]),t._v(" "),n("li",[t._v("Composite（合成）：浏览器开始在屏幕上绘制所有图层的时候；")])]),t._v(" "),n("p",[t._v("在第四步合成上，使用 transform 和 opacity 两个属性实现四种最常用的动画：")]),t._v(" "),n("ul",[n("li",[t._v("位置动画：translateX(n) translateY(n) translateZ(n);")]),t._v(" "),n("li",[t._v("大小动画：transform: scale(n);")]),t._v(" "),n("li",[t._v("旋转动画：transform: rotate(ndeg);")]),t._v(" "),n("li",[t._v("不透明度动画：opacity: n;")])])])}),[],!1,null,null,null);n.default=i.exports}}]);