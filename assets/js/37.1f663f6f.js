(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{485:function(t,s,r){"use strict";r.r(s);var c=r(3),v=Object(c.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("当浏览器碰到 script 脚本的时候 :")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[s("code",[t._v('<script src="script.js">')]),t._v("\n没有 defer 或 async,浏览器会立即加载并执行指定的脚本,“立即”指的是在渲染该 script 标签之下的文档元素之前,也就是说不等待后续载入的文档元素,读到就加载并执行。浏览器在解析 HTML 的时候，如果遇到一个没有任何属性的 script 标签，就会暂停解析，先发送网络请求获取该 JS 脚本的代码内容，然后让 JS 引擎执行该代码，当代码执行完毕后恢复解析。")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[s("code",[t._v('<script async src="script.js">')]),t._v("\n有 async,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。当浏览器遇到带有 async 属性的 script 时，请求该脚本的网络请求是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器会暂停解析，先让 JS 引擎执行代码，执行完毕后再进行解析;当然，如果在 JS 脚本请求回来之前，HTML 已经解析完毕了，那就啥事没有，立即执行 JS 代码，所以 async 是不可控的，因为执行时间不确定，你如果在异步 JS 脚本中获取某个 DOM 元素，有可能获取到也有可能获取不到。而且如果存在多个 async 的时候，它们之间的执行顺序也不确定，完全依赖于网络传输结果，谁先到执行谁。")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[s("code",[t._v('<script defer src="myscript.js">')]),t._v("\n有 defer,加载后续文档元素的过程将和 script.js 的加载并行进行（异步）,但是 script.js 的执行要在所有元素解析完成之后,DOMContentLoaded 事件触发之前完成。当浏览器遇到带有 defer 属性的 script 时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器不会暂停解析并执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码;如果存在多个 defer script 标签，浏览器（IE9 及以下除外）会保证它们按照在 HTML 中出现的顺序执行，不会破坏 JS 脚本之间的依赖关系。")])])]),t._v(" "),s("li",[s("p",[t._v("从实用角度来说,首先把所有脚本都丢到 "),t._v(" 之前是最佳实践,因为对于旧浏览器来说这是唯一的优化选择,此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。")])])]),t._v(" "),s("p",[t._v("总结：最后，根据上面的分析，不同类型 script 的执行顺序及其是否阻塞解析 HTML 总结如下：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("script 标签")]),t._v(" "),s("th",[t._v("js 执行顺序")]),t._v(" "),s("th",[t._v("是否阻塞解析 HTML")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("code",[t._v("<script>")])]),t._v(" "),s("td",[t._v("在 HTML 中的顺序")]),t._v(" "),s("td",[t._v("阻塞")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("<script async>")])]),t._v(" "),s("td",[t._v("网络请求返回顺序")]),t._v(" "),s("td",[t._v("可能阻塞，也可能不阻塞")])]),t._v(" "),s("tr",[s("td",[s("code",[t._v("<script defer>")])]),t._v(" "),s("td",[t._v("在 HTML 中的顺序")]),t._v(" "),s("td",[t._v("不阻塞")])])])])])}),[],!1,null,null,null);s.default=v.exports}}]);