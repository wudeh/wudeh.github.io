(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{516:function(t,n,l){"use strict";l.r(n);var i=l(3),e=Object(i.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("ul",[n("li",[t._v("① let 有无变量提升取决于你如何定义变量提升。")]),t._v(" "),n("li",[t._v("② 若「变量提升」是指变量可在声明语句之前被调用，则 let 没有变量提升；若「变量提升」是指变量在声明语句之前就被执行上下文记住，则 let 有变量提升。")]),t._v(" "),n("li",[t._v("③ JS 代码是即时编译与执行的，一个函数作用域会拥有一个执行上下文，执行上下文是一块存储空间。执行上下文内又有一个名为「变量环境」和「词法环境」的东西。")]),t._v(" "),n("li",[t._v("④ 由 var 和 function 声明的变量，在代码编译完成后，执行之前，其变量名和值就被存储在变量环境中了，所以在代码执行阶段的任何时刻，都可以调用它们，自然也能在声明语句之前调用了。")]),t._v(" "),n("li",[t._v("⑤ 由 const 和 let 声明的变量，在代码编译完成后，执行之前，其变量名被存储在词法环境中，代码执行过程中会从依据「词法环境→变量环境→闭包/上一个作用域」的顺序来查找变量，而词法环境所存储的值被要求只有在声明语句之后才能调用。所以会存在暂时性死区，但变量又确确实实被执行上下文提前记住了，所以可以把暂时性死区理解为「变量暂时不能使用的阶段」。所以得出结论 ①")]),t._v(" "),n("li",[t._v("函数编译阶段会初始化内部声明的变量，let const放在词法环境里，初始状态是unitialized，var放在变量环境里，初始值是undefined。不存在记住不记住的概念。区别就是undefined值可以读取，uninitialized状态的变量在读取时会抛出异常")])])])}),[],!1,null,null,null);n.default=e.exports}}]);