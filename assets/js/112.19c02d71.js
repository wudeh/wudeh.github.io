(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{560:function(T,v,_){"use strict";_.r(v);var t=_(3),a=Object(t.a)({},(function(){var T=this,v=T._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":T.$parent.slotKey}},[v("p",[T._v("HTTP3.0 又称为 HTTP Over QUIC，其弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议来实现。")]),T._v(" "),v("ul",[v("li",[T._v("HTTP3.0 既然选择了 QUIC 协议，也就意味着 HTTP3.0 基本继承了 HTTP2.0 的强大功能，并且进一步解决了 HTTP2.0 存在的一些问题，同时必然引入了新的问题。")])]),T._v(" "),v("h3",{attrs:{id:"实现了类似-tcp-的流量控制、传输可靠性的功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现了类似-tcp-的流量控制、传输可靠性的功能"}},[T._v("#")]),T._v(" 实现了类似 TCP 的流量控制、传输可靠性的功能")]),T._v(" "),v("p",[T._v("虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。\nQUIC 协议到底改进在哪些方面呢？主要有如下几点：")]),T._v(" "),v("ul",[v("li",[T._v("可插拔 — 应用程序层面就能实现不同的拥塞控制算法。")]),T._v(" "),v("li",[T._v("单调递增的 Packet Number — 使用 Packet Number 代替了 TCP 的 seq。")]),T._v(" "),v("li",[T._v("不允许 Reneging — 一个 Packet 只要被 Ack，就认为它一定被正确接收。")]),T._v(" "),v("li",[T._v("前向纠错（FEC）")]),T._v(" "),v("li",[T._v("更多的 Ack 块和增加 Ack Delay 时间。")]),T._v(" "),v("li",[T._v("基于 stream 和 connection 级别的流量控制。")])]),T._v(" "),v("h3",{attrs:{id:"实现了快速握手功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现了快速握手功能"}},[T._v("#")]),T._v(" 实现了快速握手功能")]),T._v(" "),v("p",[T._v("由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。")]),T._v(" "),v("h3",{attrs:{id:"集成了-tls-加密功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集成了-tls-加密功能"}},[T._v("#")]),T._v(" 集成了 TLS 加密功能")]),T._v(" "),v("p",[T._v("目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。\n在完全握手情况下，需要 1-RTT 建立连接。 TLS1.3 恢复会话可以直接发送加密后的应用数据，不需要额外的 TLS 握手，也就是 0-RTT。\n但是 TLS1.3 也并不完美。TLS 1.3 的 0-RTT 无法保证前向安全性(Forward secrecy)。简单讲就是，如果当攻击者通过某种手段获取到了 Session Ticket Key，那么该攻击者可以解密以前的加密数据。\n要缓解该问题可以通过设置使得与 Session Ticket Key 相关的 DH 静态参数在短时间内过期（一般几个小时）。")]),T._v(" "),v("h3",{attrs:{id:"多路复用-彻底解决-tcp-中队头阻塞的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多路复用-彻底解决-tcp-中队头阻塞的问题"}},[T._v("#")]),T._v(" 多路复用，彻底解决 TCP 中队头阻塞的问题")]),T._v(" "),v("p",[T._v("和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。")]),T._v(" "),v("h3",{attrs:{id:"连接迁移"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#连接迁移"}},[T._v("#")]),T._v(" 连接迁移")]),T._v(" "),v("p",[T._v("TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。")]),T._v(" "),v("h3",{attrs:{id:"队头阻塞问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#队头阻塞问题"}},[T._v("#")]),T._v(" 队头阻塞问题")]),T._v(" "),v("ul",[v("li",[v("p",[T._v("队头阻塞 Head-of-line blocking(缩写为 HOL blocking)是计算机网络中是一种性能受限的现象，通俗来说就是：一个数据包影响了一堆数据包，它不来大家都走不了。")])]),T._v(" "),v("li",[v("p",[T._v("队头阻塞问题可能存在于 HTTP 层和 TCP 层，在 HTTP1.x 时两个层次都存在该问题。")])]),T._v(" "),v("li",[v("p",[T._v("HTTP2.0 协议的多路复用机制解决了 HTTP 层的队头阻塞问题，但是在 TCP 层仍然存在队头阻塞问题。")])]),T._v(" "),v("li",[v("p",[T._v("TCP 协议在收到数据包之后，这部分数据可能是乱序到达的，但是 TCP 必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。")])]),T._v(" "),v("li",[v("p",[T._v("QUIC 协议是基于 UDP 协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。")])])]),T._v(" "),v("h3",{attrs:{id:"连接迁移-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#连接迁移-2"}},[T._v("#")]),T._v(" 连接迁移")]),T._v(" "),v("p",[T._v("网络切换几乎无时无刻不在发生。")]),T._v(" "),v("p",[T._v("TCP 协议使用五元组来表示一条唯一的连接，当我们从 4G 环境切换到 wifi 环境时，手机的 IP 地址就会发生变化，这时必须创建新的 TCP 连接才能继续传输数据。")]),T._v(" "),v("p",[T._v("QUIC 协议基于 UDP 实现摒弃了五元组的概念，使用 64 位的随机数作为连接的 ID，并使用该 ID 表示连接。")]),T._v(" "),v("p",[T._v("基于 QUIC 协议之下，我们在日常 wifi 和 4G 切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。")]),T._v(" "),v("h3",{attrs:{id:"丢包重传"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#丢包重传"}},[T._v("#")]),T._v(" 丢包重传")]),T._v(" "),v("p",[T._v("HTTP/2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。")]),T._v(" "),v("ul",[v("li",[T._v("HTTP/2 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。")])]),T._v(" "),v("p",[T._v("这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。")]),T._v(" "),v("p",[T._v("UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。")]),T._v(" "),v("ul",[v("li",[T._v("QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。")]),T._v(" "),v("li",[T._v("TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。")]),T._v(" "),v("li",[T._v("HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);