<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 2.x 知识点总结 | wudeh的学习基地</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="wudeh的学习基地是wudeh的个人博客，用于记录学习笔记、分享音乐、书籍、旅行等个人兴趣的站点。">
    <meta name="keywords" content="wudeh,wudeh的博客,博客,个人博客,vue,vuejs,vuepress,vuepress-theme-reco">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.1c8bbb9e.css" as="style"><link rel="preload" href="/assets/js/app.c1055618.js" as="script"><link rel="preload" href="/assets/js/2.fe3915ee.js" as="script"><link rel="preload" href="/assets/js/128.cda83341.js" as="script"><link rel="preload" href="/assets/js/4.439663eb.js" as="script"><link rel="prefetch" href="/assets/js/10.4d85798f.js"><link rel="prefetch" href="/assets/js/100.2b931b0a.js"><link rel="prefetch" href="/assets/js/101.d2cb2699.js"><link rel="prefetch" href="/assets/js/102.8bfae57a.js"><link rel="prefetch" href="/assets/js/103.7eadbc17.js"><link rel="prefetch" href="/assets/js/104.136157ec.js"><link rel="prefetch" href="/assets/js/105.cd389783.js"><link rel="prefetch" href="/assets/js/106.d6a94cad.js"><link rel="prefetch" href="/assets/js/107.5df04ba1.js"><link rel="prefetch" href="/assets/js/108.43a16d88.js"><link rel="prefetch" href="/assets/js/109.fdac1e46.js"><link rel="prefetch" href="/assets/js/11.29fd6b40.js"><link rel="prefetch" href="/assets/js/110.a04a18c7.js"><link rel="prefetch" href="/assets/js/111.4013fbc8.js"><link rel="prefetch" href="/assets/js/112.66711a6a.js"><link rel="prefetch" href="/assets/js/113.3838cf43.js"><link rel="prefetch" href="/assets/js/114.aea9f994.js"><link rel="prefetch" href="/assets/js/115.a0a7e307.js"><link rel="prefetch" href="/assets/js/116.c3e33252.js"><link rel="prefetch" href="/assets/js/117.e81d17c3.js"><link rel="prefetch" href="/assets/js/118.312d4eef.js"><link rel="prefetch" href="/assets/js/119.b53473a9.js"><link rel="prefetch" href="/assets/js/12.98ccec16.js"><link rel="prefetch" href="/assets/js/120.311e847e.js"><link rel="prefetch" href="/assets/js/121.1e272810.js"><link rel="prefetch" href="/assets/js/122.7f1e3d77.js"><link rel="prefetch" href="/assets/js/123.bfe0bb19.js"><link rel="prefetch" href="/assets/js/124.976ed933.js"><link rel="prefetch" href="/assets/js/125.575616ed.js"><link rel="prefetch" href="/assets/js/126.131d46cd.js"><link rel="prefetch" href="/assets/js/127.091098da.js"><link rel="prefetch" href="/assets/js/129.999cabff.js"><link rel="prefetch" href="/assets/js/13.528796ac.js"><link rel="prefetch" href="/assets/js/130.7da4c4fd.js"><link rel="prefetch" href="/assets/js/131.5b91347e.js"><link rel="prefetch" href="/assets/js/132.0a36d5d5.js"><link rel="prefetch" href="/assets/js/133.587ef13b.js"><link rel="prefetch" href="/assets/js/134.c20c653b.js"><link rel="prefetch" href="/assets/js/135.5e6f3be6.js"><link rel="prefetch" href="/assets/js/136.2491aa02.js"><link rel="prefetch" href="/assets/js/137.a960c2d2.js"><link rel="prefetch" href="/assets/js/138.cefdf8fe.js"><link rel="prefetch" href="/assets/js/139.2adcd399.js"><link rel="prefetch" href="/assets/js/14.fdc83a8f.js"><link rel="prefetch" href="/assets/js/140.a0bcad1b.js"><link rel="prefetch" href="/assets/js/141.3302d5a5.js"><link rel="prefetch" href="/assets/js/142.8c924e73.js"><link rel="prefetch" href="/assets/js/143.52f28ae2.js"><link rel="prefetch" href="/assets/js/144.085dbfc7.js"><link rel="prefetch" href="/assets/js/145.54016665.js"><link rel="prefetch" href="/assets/js/146.8002d1c1.js"><link rel="prefetch" href="/assets/js/147.b3ffb421.js"><link rel="prefetch" href="/assets/js/148.10df5ea2.js"><link rel="prefetch" href="/assets/js/149.27c7e091.js"><link rel="prefetch" href="/assets/js/15.ce7fbb5f.js"><link rel="prefetch" href="/assets/js/150.7c093925.js"><link rel="prefetch" href="/assets/js/151.ef92cd59.js"><link rel="prefetch" href="/assets/js/152.4d625470.js"><link rel="prefetch" href="/assets/js/153.e8ce5e21.js"><link rel="prefetch" href="/assets/js/154.37538852.js"><link rel="prefetch" href="/assets/js/155.2ae8b738.js"><link rel="prefetch" href="/assets/js/156.a3ca8645.js"><link rel="prefetch" href="/assets/js/157.87c20efb.js"><link rel="prefetch" href="/assets/js/158.78a8bec9.js"><link rel="prefetch" href="/assets/js/159.1f9bdb50.js"><link rel="prefetch" href="/assets/js/16.6a39a3af.js"><link rel="prefetch" href="/assets/js/160.5b74b791.js"><link rel="prefetch" href="/assets/js/161.b9631bd3.js"><link rel="prefetch" href="/assets/js/162.73227e02.js"><link rel="prefetch" href="/assets/js/163.9676274d.js"><link rel="prefetch" href="/assets/js/17.6bb854a8.js"><link rel="prefetch" href="/assets/js/18.a7de13f5.js"><link rel="prefetch" href="/assets/js/19.ff70a01e.js"><link rel="prefetch" href="/assets/js/20.8c356370.js"><link rel="prefetch" href="/assets/js/21.f10db446.js"><link rel="prefetch" href="/assets/js/22.8a5bf96b.js"><link rel="prefetch" href="/assets/js/23.20da2fb0.js"><link rel="prefetch" href="/assets/js/24.02081f06.js"><link rel="prefetch" href="/assets/js/25.d493d32c.js"><link rel="prefetch" href="/assets/js/26.c71526ea.js"><link rel="prefetch" href="/assets/js/27.8f978d5a.js"><link rel="prefetch" href="/assets/js/28.09361c7a.js"><link rel="prefetch" href="/assets/js/29.76c34b80.js"><link rel="prefetch" href="/assets/js/3.307c93f7.js"><link rel="prefetch" href="/assets/js/30.c7c73a53.js"><link rel="prefetch" href="/assets/js/31.d76c0150.js"><link rel="prefetch" href="/assets/js/32.261d3afe.js"><link rel="prefetch" href="/assets/js/33.78e8afa9.js"><link rel="prefetch" href="/assets/js/34.27c402c3.js"><link rel="prefetch" href="/assets/js/35.160d260e.js"><link rel="prefetch" href="/assets/js/36.d06e7430.js"><link rel="prefetch" href="/assets/js/37.ab8e31bc.js"><link rel="prefetch" href="/assets/js/38.54070448.js"><link rel="prefetch" href="/assets/js/39.9e58af8a.js"><link rel="prefetch" href="/assets/js/40.4232c9bc.js"><link rel="prefetch" href="/assets/js/41.2dc7b14e.js"><link rel="prefetch" href="/assets/js/42.c5bcee42.js"><link rel="prefetch" href="/assets/js/43.f6d27eb1.js"><link rel="prefetch" href="/assets/js/44.40a337fb.js"><link rel="prefetch" href="/assets/js/45.b65adbd7.js"><link rel="prefetch" href="/assets/js/46.5868de63.js"><link rel="prefetch" href="/assets/js/47.751b594c.js"><link rel="prefetch" href="/assets/js/48.42bda3b7.js"><link rel="prefetch" href="/assets/js/49.05371a47.js"><link rel="prefetch" href="/assets/js/5.02e0b4da.js"><link rel="prefetch" href="/assets/js/50.79e28d55.js"><link rel="prefetch" href="/assets/js/51.257ac782.js"><link rel="prefetch" href="/assets/js/52.e4d26215.js"><link rel="prefetch" href="/assets/js/53.1912e958.js"><link rel="prefetch" href="/assets/js/54.551a9fec.js"><link rel="prefetch" href="/assets/js/55.93f6e502.js"><link rel="prefetch" href="/assets/js/56.81a6f9c1.js"><link rel="prefetch" href="/assets/js/57.bc0a5040.js"><link rel="prefetch" href="/assets/js/58.4297829e.js"><link rel="prefetch" href="/assets/js/59.92ee50c7.js"><link rel="prefetch" href="/assets/js/6.2b05c701.js"><link rel="prefetch" href="/assets/js/60.23944051.js"><link rel="prefetch" href="/assets/js/61.e9ab58f9.js"><link rel="prefetch" href="/assets/js/62.b2d31592.js"><link rel="prefetch" href="/assets/js/63.69486091.js"><link rel="prefetch" href="/assets/js/64.a6bd1dab.js"><link rel="prefetch" href="/assets/js/65.885c168e.js"><link rel="prefetch" href="/assets/js/66.e40615e5.js"><link rel="prefetch" href="/assets/js/67.e7adbacb.js"><link rel="prefetch" href="/assets/js/68.93d77e2c.js"><link rel="prefetch" href="/assets/js/69.09f5f135.js"><link rel="prefetch" href="/assets/js/7.c23dd64f.js"><link rel="prefetch" href="/assets/js/70.8a7fb59f.js"><link rel="prefetch" href="/assets/js/71.035f78d0.js"><link rel="prefetch" href="/assets/js/72.162697e7.js"><link rel="prefetch" href="/assets/js/73.ed617b8c.js"><link rel="prefetch" href="/assets/js/74.e6436b66.js"><link rel="prefetch" href="/assets/js/75.f067ef64.js"><link rel="prefetch" href="/assets/js/76.13b9c9f0.js"><link rel="prefetch" href="/assets/js/77.dd1b86e6.js"><link rel="prefetch" href="/assets/js/78.210cbbb3.js"><link rel="prefetch" href="/assets/js/79.b19afa61.js"><link rel="prefetch" href="/assets/js/8.ab5fae2f.js"><link rel="prefetch" href="/assets/js/80.bd817979.js"><link rel="prefetch" href="/assets/js/81.90305c9c.js"><link rel="prefetch" href="/assets/js/82.51a9885e.js"><link rel="prefetch" href="/assets/js/83.cc324c74.js"><link rel="prefetch" href="/assets/js/84.0333a975.js"><link rel="prefetch" href="/assets/js/85.0bc5fd2f.js"><link rel="prefetch" href="/assets/js/86.15946d83.js"><link rel="prefetch" href="/assets/js/87.7c1233ad.js"><link rel="prefetch" href="/assets/js/88.bde6468c.js"><link rel="prefetch" href="/assets/js/89.79864ee2.js"><link rel="prefetch" href="/assets/js/9.aaa79318.js"><link rel="prefetch" href="/assets/js/90.7c5a6ffd.js"><link rel="prefetch" href="/assets/js/91.dbdb8987.js"><link rel="prefetch" href="/assets/js/92.33048b3b.js"><link rel="prefetch" href="/assets/js/93.de71fe0a.js"><link rel="prefetch" href="/assets/js/94.89d7b6f6.js"><link rel="prefetch" href="/assets/js/95.7b0682af.js"><link rel="prefetch" href="/assets/js/96.5f3c906c.js"><link rel="prefetch" href="/assets/js/97.1346f148.js"><link rel="prefetch" href="/assets/js/98.434d253c.js"><link rel="prefetch" href="/assets/js/99.01788bf6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1c8bbb9e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container value effect" data-v-ecfc9fc4><div class="global-loading-wrapper" data-v-137da995 data-v-ecfc9fc4 data-v-ecfc9fc4><div class="loader-main" data-v-137da995><img src="/assets/img/loading.18d75e19.gif" alt="loading" data-v-137da995></div></div> <div class="hide" data-v-ecfc9fc4><header class="navbar" data-v-ecfc9fc4><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="wudeh的学习基地" class="logo"> <span class="site-name">wudeh的学习基地</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">选择模式</h4> <ul class="color-mode-options"><li class="dark">深色模式</li><li class="light active">浅色模式</li><li class="read">阅读模式</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <ul class="suggestions" style="display:none;"></ul></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i></i>前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>文档教程</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/web/docs/imooc/wiki/" class="nav-link"><i class="iconfont reco-blog"></i>慕课教程
</a></li><li class="dropdown-subitem"><a href="/web/docs/es6/" class="nav-link"><i class="iconfont reco-blog"></i>ES6 入门教程
</a></li><li class="dropdown-subitem"><a href="/web/docs/wangdoc/javascript/" class="nav-link"><i class="iconfont reco-blog"></i>网道-JavaScript 教程
</a></li><li class="dropdown-subitem"><a href="/web/docs/angular/" class="nav-link"><i class="iconfont reco-blog"></i>Angular 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/react/" class="nav-link"><i class="iconfont reco-blog"></i>React 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/vue/" class="nav-link"><i class="iconfont reco-blog"></i>Vue 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/node/" class="nav-link"><i class="iconfont reco-blog"></i>Node 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/babel/" class="nav-link"><i class="iconfont reco-blog"></i>Babel 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/webpack/" class="nav-link"><i class="iconfont reco-blog"></i>Webpack 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/typescript/" class="nav-link"><i class="iconfont reco-blog"></i>TypeScript 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/runoob/" class="nav-link"><i class="iconfont reco-blog"></i>菜鸟教程
</a></li><li class="dropdown-subitem"><a href="/web/docs/docschina/" class="nav-link"><i class="iconfont reco-blog"></i>印记中文
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-api"></i>索引
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link"><i class="iconfont reco-category"></i>分类
</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link"><i class="iconfont reco-tag"></i>标签
</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link"><i class="iconfont reco-date"></i>归档
</a></li></ul></div></div><div class="nav-item"><a href="/bookshop/message-board/" class="nav-link"><i class="iconfont reco-suggestion"></i>留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>关于
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>联系</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/wudeh" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/bookshop/linkme/" class="nav-link"><i class="iconfont reco-account"></i>关于我
</a></li></ul></li><li class="dropdown-item"><h4>博客</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/wudeh/wudeh.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-document"></i>本站源码
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://wudeh.github.io/old-blog" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-document"></i>老版博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/bookshop/friendslink/" class="nav-link"><i class="iconfont reco-friend"></i>友情链接
</a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-ecfc9fc4></div> <aside class="sidebar" data-v-ecfc9fc4><PersonalInfo data-v-ecfc9fc4></PersonalInfo> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i></i>前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>文档教程</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/web/docs/imooc/wiki/" class="nav-link"><i class="iconfont reco-blog"></i>慕课教程
</a></li><li class="dropdown-subitem"><a href="/web/docs/es6/" class="nav-link"><i class="iconfont reco-blog"></i>ES6 入门教程
</a></li><li class="dropdown-subitem"><a href="/web/docs/wangdoc/javascript/" class="nav-link"><i class="iconfont reco-blog"></i>网道-JavaScript 教程
</a></li><li class="dropdown-subitem"><a href="/web/docs/angular/" class="nav-link"><i class="iconfont reco-blog"></i>Angular 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/react/" class="nav-link"><i class="iconfont reco-blog"></i>React 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/vue/" class="nav-link"><i class="iconfont reco-blog"></i>Vue 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/node/" class="nav-link"><i class="iconfont reco-blog"></i>Node 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/babel/" class="nav-link"><i class="iconfont reco-blog"></i>Babel 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/webpack/" class="nav-link"><i class="iconfont reco-blog"></i>Webpack 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/typescript/" class="nav-link"><i class="iconfont reco-blog"></i>TypeScript 文档
</a></li><li class="dropdown-subitem"><a href="/web/docs/runoob/" class="nav-link"><i class="iconfont reco-blog"></i>菜鸟教程
</a></li><li class="dropdown-subitem"><a href="/web/docs/docschina/" class="nav-link"><i class="iconfont reco-blog"></i>印记中文
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-api"></i>索引
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link"><i class="iconfont reco-category"></i>分类
</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link"><i class="iconfont reco-tag"></i>标签
</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link"><i class="iconfont reco-date"></i>归档
</a></li></ul></div></div><div class="nav-item"><a href="/bookshop/message-board/" class="nav-link"><i class="iconfont reco-suggestion"></i>留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>关于
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>联系</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/wudeh" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="/bookshop/linkme/" class="nav-link"><i class="iconfont reco-account"></i>关于我
</a></li></ul></li><li class="dropdown-item"><h4>博客</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="https://github.com/wudeh/wudeh.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-document"></i>本站源码
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-subitem"><a href="https://wudeh.github.io/old-blog" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-document"></i>老版博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/bookshop/friendslink/" class="nav-link"><i class="iconfont reco-friend"></i>友情链接
</a></li></ul></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><a href="/pages/f16531008c5a4/" class="sidebar-link">【React】react hooks</a></li><li><a href="/pages/005afb7501ebf/" class="sidebar-link">【React】react 高阶基础</a></li><li><a href="/pages/785710818c193/" class="sidebar-link">vue-cli3 全面配置</a></li><li><a href="/pages/0d5c101d17afe/" class="sidebar-link">Vue 转 React不完全指北</a></li><li><a href="/pages/38a448a32b1a5/" class="sidebar-link">【React】一名 vueCoder 总结的 React 基础</a></li><li><a href="/pages/72dcdd7f52781/" class="sidebar-link">【vue】🔥vue2.x底层的问题，你能答多少</a></li><li><a href="/pages/ebb460710fd62/" class="sidebar-link">mitt.js 跨框架通信方式</a></li><li><a href="/pages/c97be6f9b007/" class="sidebar-link">vue3的相关api</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span></span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/eb00ff6790769/" class="sidebar-link">实现 vue 动态缓存</a></li><li><a href="/pages/b50d916f7471d/" aria-current="page" class="active sidebar-link">Vue 2.x 知识点总结</a></li><li><a href="/pages/0b1f4ac58e0ec/" class="sidebar-link">Vue 定时器销毁</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span></span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-8"><div class="articleInfo-wrap" data-v-13f19dad><div class="articleInfo" data-v-13f19dad><ul class="breadcrumbs" data-v-13f19dad><li data-v-13f19dad><a href="/" title="首页" class="fa fa-laptop-house router-link-active" data-v-13f19dad></a></li> <li data-v-13f19dad><a href="/categories/?category=%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6" title="分类" data-v-13f19dad>前端框架</a></li> <!----> <!----></ul> <div class="info" data-v-13f19dad><div title="作者" class="author fa fa-user" data-v-13f19dad><a href="javascript:;" data-v-13f19dad>wudeh</a></div> <div title="创建时间" class="date fa fa-calendar-alt" data-v-13f19dad><a href="javascript:;" data-v-13f19dad>2020/06/01 00:00:00</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">
            Vue 2.x 知识点总结
          </h1> <div class="theme-vdoing-content content__default"><h2 id="vue-跟-react-的异同点"><a href="#vue-跟-react-的异同点" class="header-anchor">#</a> Vue 跟 React 的异同点</h2> <p>相同点：</p> <ul><li>1.都使用了虚拟 dom</li> <li>2.组件化开发</li> <li>3.都是单向数据流(父子组件之间，不建议子修改父传下来的数据)</li> <li>4.都支持服务端渲染</li></ul> <p>不同点：</p> <ul><li>1.React 的 JSX，Vue 的 template</li> <li>2.数据变化，React 手动(setState)，Vue 自动(初始化已响应式处理，Object.defineProperty)</li> <li>3.React 单向绑定，Vue 双向绑定</li> <li>4.React 的 Redux，Vue 的 Vuex</li></ul> <h2 id="mvvm-和-mvc"><a href="#mvvm-和-mvc" class="header-anchor">#</a> MVVM 和 MVC</h2> <p>MVC</p> <ul><li>Model(模型)：负责从数据库中取数据</li> <li>View(视图)：负责展示数据的地方</li> <li>Controller(控制器)：用户交互的地方，例如点击事件等等
思想：Controller 将 Model 的数据展示在 View 上</li></ul> <p>MVVM</p> <ul><li>VM：也就是 View-Model，做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</li> <li>思想：实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应 Vue 数据驱动的思想）</li></ul> <p>Vue 是 MVVM 框架，但是不是严格符合 MVVM，因为 MVVM 规定 Model 和 View 不能直接通信，而 Vue 的 ref 可以做到这点</p> <h2 id="为什么-data-是个函数并且返回一个对象呢"><a href="#为什么-data-是个函数并且返回一个对象呢" class="header-anchor">#</a> 为什么 data 是个函数并且返回一个对象呢？</h2> <p>data 之所以只一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行 data 函数并返回新的数据对象，这样，可以避免多处调用之间的数据污染。</p> <h2 id="组件之间的传值方式"><a href="#组件之间的传值方式" class="header-anchor">#</a> 组件之间的传值方式</h2> <ul><li>父组件传值给子组件，子组件使用 props 进行接收</li> <li>子组件传值给父组件，子组件使用$emit+事件对父组件进行传值</li> <li>组件中可以使用$parent和$children 获取到父组件实例和子组件实例，进而获取数据</li> <li>使用$attrs和$listeners，在对一些组件进行二次封装时可以方便传值，例如 A-&gt;B-&gt;C</li> <li>使用$refs 获取组件实例，进而获取数据</li> <li>使用 Vuex 进行状态管理</li> <li>使用 eventBus 进行跨组件触发事件，进而传递数据</li> <li>祖孙组件：使用 provide 和 inject</li> <li>使用浏览器本地缓存，例如 localStorage</li> <li>父组件获取子组件数据：作用域插槽</li></ul> <h2 id="v-on-监听多个方法"><a href="#v-on-监听多个方法" class="header-anchor">#</a> v-on 监听多个方法</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;input type=&quot;text&quot; v-on=&quot;{ input:onInput,focus:onFocus,blur:onBlur, }&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="vue-的生命周期方法"><a href="#vue-的生命周期方法" class="header-anchor">#</a> Vue 的生命周期方法</h2> <ul><li>beforeCreate(支持服务端渲染) 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问</li> <li>created(支持服务端渲染) 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom</li> <li>beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。</li> <li>mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点</li> <li>beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</li> <li>updated 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。</li> <li>beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。</li> <li>destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</li> <li>activated keep-alive 专属，组件被激活时调用</li> <li>deactivated keep-alive 专属，组件被销毁时调用</li> <li>errorCaptured(支持服务端渲染) 当捕获来自子孙组件的错误时被调用，这个钩子有三个参数：错误对象，发生错误的组件实例，错误来源信息的字符串；可以返回 false 以防止错误继续向上传递</li></ul> <p>异步请求在哪一步发起？</p> <p>可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。
如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p> <ul><li>能更快获取到服务端数据，减少页面 loading 时间；</li> <li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul> <h2 id="父子组件生命周期钩子函数执行顺序"><a href="#父子组件生命周期钩子函数执行顺序" class="header-anchor">#</a> 父子组件生命周期钩子函数执行顺序</h2> <p>加载渲染过程</p> <ul><li>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</li></ul> <p>子组件更新过程</p> <ul><li>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</li></ul> <p>父组件更新过程</p> <ul><li>父 beforeUpdate-&gt;父 updated</li></ul> <p>销毁过程</p> <ul><li>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</li></ul> <h2 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="header-anchor">#</a> v-if 和 v-show</h2> <ul><li>1.v-if 是通过控制 dom 元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁，v-show 由 false 变为 true 的时候不会触发组件的生命周期。 v-if 由 false 变为 true 则会触发组件的 beforeCreate、create、beforeMount、mounted 钩子，由 true 变为 false 会触发组件的 beforeDestory、destoryed 方法。</li> <li>2.v-show 是通过控制 dom 元素的 css 样式来实现显隐，不会销毁(display: none)</li> <li>3.频繁或者大数量显隐使用 v-show，否则使用 v-if</li></ul> <h2 id="this-xxx-读取顺序"><a href="#this-xxx-读取顺序" class="header-anchor">#</a> this.xxx 读取顺序</h2> <p>props -&gt; methods -&gt; data -&gt; computed</p> <h2 id="组件中-name-的作用"><a href="#组件中-name-的作用" class="header-anchor">#</a> 组件中 name 的作用</h2> <ul><li>项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤</li> <li>DOM 做递归组件时需要调用自身 name</li> <li>vue-devtools 调试工具里显示的组件名称是由 vue 中组件 name 决定的</li></ul> <h2 id="computed-和-watch"><a href="#computed-和-watch" class="header-anchor">#</a> computed 和 watch</h2> <h3 id="computed"><a href="#computed" class="header-anchor">#</a> computed</h3> <p>本质是一个惰性求值的观察者<code>computed watcher</code>。其内部通过 <code>this.dirty</code> 属性标记计算属性是否需要重新求值。</p> <p>当 <code>computed</code> 的依赖状态发生改变时,就会通知这个惰性的 <code>watcher</code>,<code>computed watcher</code> 通过 <code>this.dep.subs.length</code> 判断有没有订阅者,
有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 <code>watcher</code> 重新渲染，本质上是一种优化。)
没有的话,仅仅把 <code>this.dirty = true</code> (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 <code>lazy</code>（懒计算）特性。)</p> <h3 id="watch"><a href="#watch" class="header-anchor">#</a> watch</h3> <p><code>watch</code>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开 deep：true 选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>watch: {
  firstName: {
    handler(newName, oldName) {
      this.fullName = newName + ' ' + this.lastName;
    },
    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法
    immediate: true
  }
}

watch: {
  obj: {
    handler(newName, oldName) {
      console.log('obj.a changed');
    },
    immediate: true,
    deep: true
  }
}

// 字符串的形式监听
watch: {
  'obj.a': {
    handler(newName, oldName) {
      console.log('obj.a changed');
    },
    immediate: true,
    // deep: true
  }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>注意：<code>Watcher</code> : 观察者对象 , 实例分为渲染 <code>watcher</code> (<code>render watcher</code>),计算属性 <code>watcher</code> (<code>computed watcher</code>),侦听器 <code>watcher</code>（<code>user watcher</code>）三种</p> <h2 id="vue-的数据频繁变化但只会更新一次"><a href="#vue-的数据频繁变化但只会更新一次" class="header-anchor">#</a> Vue 的数据频繁变化但只会更新一次</h2> <ul><li>检测到数据变化</li> <li>开启一个队列</li> <li>在同一事件循环中缓冲所有数据改变</li> <li>如果同一个 watcher (watcherId 相同)被多次触发，只会被推入到队列中一次</li></ul> <p>不优化，每一个数据变化都会执行: setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run</p> <p>优化后：执行顺序 update -&gt; queueWatcher -&gt; 维护观察者队列（重复 id 的 Watcher 处理） -&gt; waiting 标志位处理 -&gt; 处理$nextTick（在为微任务或者宏任务中异步更新 DOM）</p> <h2 id="为什么访问-data-属性不需要带-data"><a href="#为什么访问-data-属性不需要带-data" class="header-anchor">#</a> 为什么访问 data 属性不需要带 data</h2> <p>访问属性代理 this.data.xxx 转换 this.xxx 的实现</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    /** 将 某一个对象的属性 访问 映射到 对象的某一个属性成员上 */
    function proxy( target, prop, key ) {
      Object.defineProperty( target, key, {
        enumerable: true,
        configurable: true,
        get () {
          return target[ prop ][ key ];
        },
        set ( newVal ) {
          target[ prop ][ key ] = newVal;
        }
      } );
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="vue-中的-key-到底有什么用"><a href="#vue-中的-key-到底有什么用" class="header-anchor">#</a> Vue 中的 key 到底有什么用</h2> <p>key 是给每一个 vnode 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速
注意：在没有 key 的情况下，会更快。
引用官网的话：key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p> <p>更快速 : key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度 O(n),Map 的时间复杂度仅仅为 O(1)</p> <p>更准确 : 因为带 key 就不是就地复用了,在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确,如果不加 key,会导致之前节点的状态被保留下来,会产生一系列的 bug。</p> <p>vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。</p> <h3 id="为什么不能用-index-做-key"><a href="#为什么不能用-index-做-key" class="header-anchor">#</a> 为什么不能用 index 做 key</h3> <p>如果 <code>v-for</code> 中的列表数据顺序被改变，在 <code>diff</code> 比较中将错误地复用旧节点，导致不必要的重新渲染步骤</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;{{item.name}}&lt;/div&gt;

list: [
    { name: '小明', id: '123' },
    { name: '小红', id: '124' },
    { name: '小花', id: '125' }
]

渲染为
&lt;div key=&quot;0&quot;&gt;小明&lt;/div&gt;
&lt;div key=&quot;1&quot;&gt;小红&lt;/div&gt;
&lt;div key=&quot;2&quot;&gt;小花&lt;/div&gt;

现在我执行 list.unshift({ name: '小林', id: '122' })

渲染为
&lt;div key=&quot;0&quot;&gt;小林&lt;/div&gt;
&lt;div key=&quot;1&quot;&gt;小明&lt;/div&gt;
&lt;div key=&quot;2&quot;&gt;小红&lt;/div&gt;
&lt;div key=&quot;3&quot;&gt;小花&lt;/div&gt;


新旧对比

&lt;div key=&quot;0&quot;&gt;小明&lt;/div&gt;  &lt;div key=&quot;0&quot;&gt;小林&lt;/div&gt;
&lt;div key=&quot;1&quot;&gt;小红&lt;/div&gt;  &lt;div key=&quot;1&quot;&gt;小明&lt;/div&gt;
&lt;div key=&quot;2&quot;&gt;小花&lt;/div&gt;  &lt;div key=&quot;2&quot;&gt;小红&lt;/div&gt;
                         &lt;div key=&quot;3&quot;&gt;小花&lt;/div&gt;

可以看出，如果用index做key的话，其实是更新了原有的三项，并新增了小花，虽然达到了渲染目的，但是损耗性能

现在我们使用id来做key，渲染为

&lt;div key=&quot;123&quot;&gt;小明&lt;/div&gt;
&lt;div key=&quot;124&quot;&gt;小红&lt;/div&gt;
&lt;div key=&quot;125&quot;&gt;小花&lt;/div&gt;

现在我执行 list.unshift({ name: '小林', id: '122' })，渲染为

&lt;div key=&quot;122&quot;&gt;小林&lt;/div&gt;
&lt;div key=&quot;123&quot;&gt;小明&lt;/div&gt;
&lt;div key=&quot;124&quot;&gt;小红&lt;/div&gt;
&lt;div key=&quot;125&quot;&gt;小花&lt;/div&gt;

新旧对比

                           &lt;div key=&quot;122&quot;&gt;小林&lt;/div&gt;
&lt;div key=&quot;123&quot;&gt;小明&lt;/div&gt;  &lt;div key=&quot;123&quot;&gt;小明&lt;/div&gt;
&lt;div key=&quot;124&quot;&gt;小红&lt;/div&gt;  &lt;div key=&quot;124&quot;&gt;小红&lt;/div&gt;
&lt;div key=&quot;125&quot;&gt;小花&lt;/div&gt;  &lt;div key=&quot;125&quot;&gt;小花&lt;/div&gt;

可以看出，原有的三项都不变，只是新增了小林这个人，这才是最理想的结果
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><h2 id="vue-router-路由模式"><a href="#vue-router-路由模式" class="header-anchor">#</a> vue-router 路由模式</h2> <p>默认值: &quot;hash&quot; (浏览器环境) | &quot;abstract&quot; (Node.js 环境)
可选值: &quot;hash&quot; | &quot;history&quot; | &quot;abstract&quot;
配置路由模式:</p> <p>hash:</p> <ul><li>基于 location.hash 来实现的，location.hash 的值就是 URL 中#后面的内容。其实现原理就是监听#后面的内容来发起 Ajax 请求来进行局部更新，而不需要刷新整个页面。</li> <li>使用 hashchange 事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 hashchange 事件：浏览器前进后退改变 URL、a 标签改变 URL、window.location 改变 URL。</li></ul> <p>history:</p> <ul><li>history 提供了 pushState 和 replaceState 两个方法来记录路由状态，通过这两个 API 可以改变 url 地址且不会发送请求。</li> <li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进或者后退改变 URL 时会触发 popstate 事件，通过 pushState/replaceState 或 a 标签改变 URL 不会触发 popstate 事件。可以拦截 pushState/replaceState 的调用和 a 标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</li> <li>pushState(state, title, url) 和 replaceState(state, title, url)都可以接受三个相同的参数。</li> <li>用了 HTML5 的实现，单页路由的 url 就不会多出一个 # ，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。</li></ul> <p>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p> <h2 id="params-和-query-的区别"><a href="#params-和-query-的区别" class="header-anchor">#</a> params 和 query 的区别</h2> <ul><li>url 地址显示：query 在浏览器地址栏中显示参数，params 则不显示</li> <li>query 刷新不会丢失 query 里面的数据、params 刷新会丢失 params 里面的数据。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>//query语法：
this.$router.push({path:&quot;地址&quot;,query:{id:&quot;123&quot;}}); //这是传递参数
this.$route.query.id； //这是接受参数
//params语法：
this.$router.push({name:&quot;地址&quot;,params:{id:&quot;123&quot;}}); //这是传递参数
this.$route.params.id; //这是接受参数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="动态组件"><a href="#动态组件" class="header-anchor">#</a> 动态组件</h2> <p>动态组件通过 is 特性实现。适用于根据数据、动态渲染的场景，即组件类型不确定。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;
  &lt;div v-for=&quot;val in componentsData&quot; :key=&quot;val.id&quot;&gt;
    &lt;component :is=&quot;val.type&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import CustomTitle from './CustomTitle'
import CustomText from './CustomText'
import CustomImage from './CustomImage'

export default {
  data() {
    return {
      componentsData: [{
        id: 1,
        type: 'CustomTitle'
      },{
        id: 2,
        type: 'CustomText'
      },{
        id: 3
        type: 'CustomImage'
      }]
    }
  }
}
&lt;/script&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="路由钩子函数执行顺序"><a href="#路由钩子函数执行顺序" class="header-anchor">#</a> 路由钩子函数执行顺序</h2> <h3 id="在失活的组件里调用-beforerouteleave-组件守卫。"><a href="#在失活的组件里调用-beforerouteleave-组件守卫。" class="header-anchor">#</a> 在失活的组件里调用 beforeRouteLeave 组件守卫。</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>  //A.vue
  beforeRouteLeave(to, from) {
    console.log('🚀🚀~ beforeRouteLeave');
  },
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="调用全局的-beforeeach-全局守卫"><a href="#调用全局的-beforeeach-全局守卫" class="header-anchor">#</a> 调用全局的 beforeEach 全局守卫</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>router.beforeEach((to, from, next) =&gt; {
  console.log('🚀🚀~ to:', to);
  console.log('🚀🚀~ from:', from);
  next();
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="在重用的组件里调用-beforerouteupdate-组件守卫。"><a href="#在重用的组件里调用-beforerouteupdate-组件守卫。" class="header-anchor">#</a> 在重用的组件里调用 beforeRouteUpdate 组件守卫。</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>  //A.vue
  beforeRouteUpdate(to, from) {
    console.log('🚀🚀~ beforeRouteUpdate');
  },
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="在路由配置里调用-beforeenter-路由守卫"><a href="#在路由配置里调用-beforeenter-路由守卫" class="header-anchor">#</a> 在路由配置里调用 beforeEnter 路由守卫</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//index.js
{
  path: '/a',
  component: () =&gt; import('../components/A.vue'),
  beforeEnter: (to, from) =&gt; {
   console.log('🚀🚀~ beforeEnter ');
  },
},
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="解析异步路由组件"><a href="#解析异步路由组件" class="header-anchor">#</a> 解析异步路由组件</h3> <h3 id="在被激活的组件里调用-beforerouteenter-组件守卫"><a href="#在被激活的组件里调用-beforerouteenter-组件守卫" class="header-anchor">#</a> 在被激活的组件里调用 beforeRouteEnter 组件守卫</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>  //A.vue
  beforeRouteEnter(to, from，next) {
    console.log('🚀🚀~ beforeRouteEnter');
  },
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="调用全局的-beforeresolve-全局守卫"><a href="#调用全局的-beforeresolve-全局守卫" class="header-anchor">#</a> 调用全局的 beforeResolve 全局守卫</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>router.beforeResolve((to, from, next) =&gt; {
  next();
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="调用全局的-aftereach-全局守卫"><a href="#调用全局的-aftereach-全局守卫" class="header-anchor">#</a> 调用全局的 afterEach 全局守卫</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>router.afterEach((to, from) =&gt; {
  console.log('🚀🚀~ afterEach:');
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="触发-dom-更新"><a href="#触发-dom-更新" class="header-anchor">#</a> 触发 DOM 更新</h3> <h2 id="v-if-和-v-for-不建议用在同一标签"><a href="#v-if-和-v-for-不建议用在同一标签" class="header-anchor">#</a> v-if 和 v-for 不建议用在同一标签</h2> <p>在 Vue2 中，v-for 优先级是高于 v-if 的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-for=&quot;item in [1, 2, 3, 4, 5, 6, 7]&quot; v-if=&quot;item !== 3&quot;&gt;
    {{item}}
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面的写法是 v-for 和 v-if 同时存在，会先把 7 个元素都遍历出来，然后再一个个判断是否为 3，并把 3 给隐藏掉，这样的坏处就是，渲染了无用的 3 节点，增加无用的 dom 操作，建议使用 computed 来解决</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-for=&quot;item in list&quot;&gt;
    {{item}}
&lt;/div&gt;

computed() {
    list() {
        return [1, 2, 3, 4, 5, 6, 7].filter(item =&gt; item !== 3)
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="设置动态-class-动态-style"><a href="#设置动态-class-动态-style" class="header-anchor">#</a> 设置动态 class，动态 style</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>动态class对象：&lt;div :class=&quot;{ 'is-active': true, 'red': isRed }&quot;&gt;&lt;/div&gt;
动态class数组：&lt;div :class=&quot;['is-active', isRed ? 'red' : '' ]&quot;&gt;&lt;/div&gt;
动态style对象：&lt;div :style=&quot;{ color: textColor, fontSize: '18px' }&quot;&gt;&lt;/div&gt;
动态style数组：&lt;div :style=&quot;[{ color: textColor, fontSize: '18px' }, { fontWeight: '300' }]&quot;&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="不需要响应式的数据"><a href="#不需要响应式的数据" class="header-anchor">#</a> 不需要响应式的数据</h2> <p>数据量大的死数据，如果都进行响应式处理，那会消耗大量性能</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 方法一：将数据定义在data之外
data () {
    this.list1 = { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx }
    this.list2 = { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx }
    this.list3 = { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx }
    this.list4 = { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx }
    this.list5 = { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx }
    return {}
 }

// 方法二：Object.freeze()
data () {
    return {
        list1: Object.freeze({xxxxxxxxxxxxxxxxxxxxxxxx}),
        list2: Object.freeze({xxxxxxxxxxxxxxxxxxxxxxxx}),
        list3: Object.freeze({xxxxxxxxxxxxxxxxxxxxxxxx}),
        list4: Object.freeze({xxxxxxxxxxxxxxxxxxxxxxxx}),
        list5: Object.freeze({xxxxxxxxxxxxxxxxxxxxxxxx}),
    }
 }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="对象新属性无法更新视图-删除属性无法更新视图"><a href="#对象新属性无法更新视图-删除属性无法更新视图" class="header-anchor">#</a> 对象新属性无法更新视图，删除属性无法更新视图</h2> <ul><li>原因：Object.defineProperty 没有对对象的新属性进行属性劫持</li> <li>对象新属性无法更新视图：使用 Vue.$set(obj, key, value)，组件中this.$set(obj, key, value)</li> <li>删除属性无法更新视图：使用 Vue.$delete(obj, key)，组件中this.$delete(obj, key)</li></ul> <h2 id="直接-arr-index-xxx-无法更新视图"><a href="#直接-arr-index-xxx-无法更新视图" class="header-anchor">#</a> 直接 arr[index] = xxx 无法更新视图</h2> <ul><li>原因：Vue 没有对数组进行 Object.defineProperty 的属性劫持，所以直接 arr[index] = xxx 是无法更新视图的</li> <li>使用数组的 splice 方法，arr.splice(index, 1, item)</li> <li>使用 Vue.$set(arr, index, value)</li></ul> <h2 id="插槽"><a href="#插槽" class="header-anchor">#</a> 插槽</h2> <h3 id="单个插槽"><a href="#单个插槽" class="header-anchor">#</a> 单个插槽</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//子组件 ： (假设名为：child)
&lt;template&gt;
  &lt;div class= 'child'&gt;
      &lt;slot&gt;子组件默认内容，父组件不在子组件写数据就会默认显示这个&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

//父组件：（引用子组件 child）
&lt;template&gt;
  &lt;div class= 'app'&gt;
     &lt;child&gt;
        林三心
     &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="具名插槽-子组件多个对应插入内容"><a href="#具名插槽-子组件多个对应插入内容" class="header-anchor">#</a> 具名插槽 （子组件多个对应插入内容）</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//子组件 ： (假设名为：child)
&lt;template&gt;
  &lt;div class= 'child'&gt;
      &lt;slot name='one'&gt; 这就是默认值1&lt;/slot&gt;
      &lt;slot name='two'&gt; 这就是默认值2 &lt;/slot&gt;
      &lt;slot name='three'&gt; 这就是默认值3 &lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

//父组件：（引用子组件 child）
&lt;template&gt;
  &lt;div class= 'app'&gt;
     &lt;child&gt;
        &lt;template v-slot:&quot;one&quot;&gt; 这是插入到one插槽的内容 &lt;/template&gt;
        &lt;template v-slot:&quot;two&quot;&gt; 这是插入到two插槽的内容 &lt;/template&gt;
        &lt;template v-slot:&quot;three&quot;&gt; 这是插入到three插槽的内容 &lt;/template&gt;
     &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="作用域插槽-父组件在子组件处使用子组件-data"><a href="#作用域插槽-父组件在子组件处使用子组件-data" class="header-anchor">#</a> 作用域插槽 (父组件在子组件处使用子组件 data)</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>//子组件 ： (假设名为：child)
&lt;template&gt;
  &lt;div class= 'child'&gt;
      &lt;slot name= 'one' :value1='child1'&gt; 这就是默认值1&lt;/slot&gt;    //绑定child1的数据
      &lt;slot :value2='child2'&gt; 这就是默认值2 &lt;/slot&gt;  //绑定child2的数据，这里我没有命名slot
  &lt;/div&gt;
&lt;/template&gt;

new Vue({
  el:'child',
  data:{
    child1:'数据1',
    child2:'数据2'
  }
})

//父组件：（引用子组件 child）
&lt;template&gt;
  &lt;div class='app'&gt;
     &lt;child&gt;
        &lt;template v-slot:one='slotone'&gt;
           {{ slotone.value1 }}    // 通过v-slot的语法 将子组件的value1值赋值给slotone
        &lt;/template&gt;
        &lt;template v-slot:default='slotde'&gt;
           {{ slotde.value2 }}  // 同上，由于子组件没有给slot命名，默认值就为default
        &lt;/template&gt;
     &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h2 id="nexttick-的用处"><a href="#nexttick-的用处" class="header-anchor">#</a> nextTick 的用处</h2> <ul><li>响应式数据更新后，想要立即拿到页面上对应的 DOM 数据，需要用到 nextTick</li> <li>Vue 采用的是异步更新的策略，通俗点说就是，同一事件循环内多次修改，会统一进行一次视图更新，这样才能节省性能</li> <li>.Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发
生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick 方法会在队列中加入一个回调函数，确保该函数在前面的 dom 操作完成后才调用。</li> <li>microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕；</li> <li>因为兼容性问题，vue 不得不做了 microtask 向 macrotask 的降级方案：Promise、MutationObserver、setImmediate、setTimeout.</li></ul> <h2 id="keep-alive"><a href="#keep-alive" class="header-anchor">#</a> keep-alive</h2> <p><code>keep-alive</code>组件接受三个属性参数：<code>include</code>、<code>exclude</code>、<code>max</code></p> <ul><li><code>include</code> 指定需要缓存的组件<code>name</code>集合，参数格式支持<code>String</code>, <code>RegExp</code>, <code>Array</code>。当为字符串的时候，多个组件名称以逗号隔开。</li> <li><code>exclude</code> 指定不需要缓存的组件<code>name</code>集合，参数格式和<code>include</code>一样。</li> <li><code>max</code> 指定最多可缓存组件的数量,超过数量删除第一个。参数格式支持<code>String</code>、<code>Number</code>。</li></ul> <h3 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h3> <p>keep-alive 实例会缓存对应组件的 VNode,如果命中缓存，直接从缓存对象返回对应 VNode
LRU（Least recently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。(墨菲定律：越担心的事情越会发生)</p> <h2 id="vuex-的属性"><a href="#vuex-的属性" class="header-anchor">#</a> vuex 的属性</h2> <p>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</p> <h3 id="vuex-中的数据在页面刷新后数据消失"><a href="#vuex-中的数据在页面刷新后数据消失" class="header-anchor">#</a> vuex 中的数据在页面刷新后数据消失</h3> <p>用 sessionstorage 或者 localstorage 存储数据，或者用 vuex-persist 插件</p> <h3 id="vuex-的严格模式"><a href="#vuex-的严格模式" class="header-anchor">#</a> Vuex 的严格模式</h3> <p>在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p> <p>在 Vuex.Store 构造器选项中开启,如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const store = new Vuex.Store({
    strict:true,
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="组件中使用-vuex-的-getter-和-mutation"><a href="#组件中使用-vuex-的-getter-和-mutation" class="header-anchor">#</a> 组件中使用 Vuex 的 getter 和 mutation</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中
import {mapGetters} from 'vuex'
export default{
    computed:{
        ...mapGetters(['total','discountTotal'])
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>import { mapMutations } from 'vuex'
methods:{
    ...mapMutations({
        setNumber:'SET_NUMBER',
    })
}
然后调用this.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="mutation-和-action"><a href="#mutation-和-action" class="header-anchor">#</a> mutation 和 action</h3> <ul><li>action 提交的是 mutation，而不是直接变更状态。mutation 可以直接变更状态</li> <li>action 可以包含任意异步操作。mutation 只能是同步操作</li> <li>提交方式不同</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>action 是用this.store.dispatch('ACTION_NAME',data)来提交。
mutation是用this.$store.commit('SET_NUMBER',10)来提交
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接收参数不同，mutation 第一个参数是 state，而 action 第一个参数是 context，其包含了</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    state,      // 等同于 `store.state`，若在模块中则为局部状态
    rootState,  // 等同于 `store.state`，只存在于模块中
    commit,     // 等同于 `store.commit`
    dispatch,   // 等同于 `store.dispatch`
    getters,    // 等同于 `store.getters`
    rootGetters // 等同于 `store.getters`，只存在于模块中
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="vue-的-ssr"><a href="#vue-的-ssr" class="header-anchor">#</a> Vue 的 SSR</h2> <ul><li>SSR 就是服务端渲染</li> <li>基于 nodejs serve 服务环境开发，所有 html 代码在服务端渲染</li> <li>数据返回给前端，然后前端进行“激活”，即可成为浏览器识别的 html 代码</li> <li>SSR 首次加载更快，有更好的用户体验，有更好的 seo 优化，因为爬虫能看到整个页面的内容，如果是 vue 项目，由于数据还要经过解析，这就造成爬虫并不会等待你的数据加载完成，所以其实 Vue 项目的 seo 体验并不是很好</li></ul> <h2 id="vue-的响应式原理"><a href="#vue-的响应式原理" class="header-anchor">#</a> Vue 的响应式原理</h2> <p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p> <ul><li>1、需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</li></ul> <ul><li>2、compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li></ul> <ul><li>3、Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:
① 在自身实例化时往属性订阅器(dep)里面添加自己
② 自身必须有一个 update()方法
③ 待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</li></ul> <ul><li>4、MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</li></ul> <h2 id="为什么只对对象劫持-而要对数组进行方法重写"><a href="#为什么只对对象劫持-而要对数组进行方法重写" class="header-anchor">#</a> 为什么只对对象劫持，而要对数组进行方法重写</h2> <p>因为对象最多也就几十个属性，拦截起来数量不多，但是数组可能会有几百几千项，拦截起来非常耗性能，所以直接重写数组原型上的方法，是比较节省性能的方案</p> <h2 id="vue-渲染过程"><a href="#vue-渲染过程" class="header-anchor">#</a> vue 渲染过程</h2> <ul><li><p>1.调用 compile 函数,生成 render 函数字符串 ,编译过程如下:</p></li> <li><p>parse 使用大量的正则表达式对 template 字符串进行解析，将标签、指令、属性等转化为抽象语法树 AST。模板 -&gt; AST （最消耗性能）</p></li> <li><p>optimize 遍历 AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行 diff 比较时，直接跳过这一些静态节点，优化 runtime 的性能</p></li> <li><p>generate 将最终的 AST 转化为 render 函数字符串</p></li></ul> <ul><li>2.调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象</li> <li>3.调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素</li></ul> <h2 id="prop-验证-和默认值"><a href="#prop-验证-和默认值" class="header-anchor">#</a> prop 验证，和默认值</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>props: {
    visible: {
        default: true,
        type: Boolean,
        required: true
    },
},
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="vue-中怎么重置-data"><a href="#vue-中怎么重置-data" class="header-anchor">#</a> vue 中怎么重置 data</h2> <ul><li>使用 Object.assign()，vm.data 可以获取当前状态下的 data，vm.data 可以获取当前状态下的 data</li> <li>vm.options.data(this)可以获取到组件初始化状态下的 data。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>Object.assign(this.$data, this.$options.data(this)) // 注意加this，不然取不到

data(){ a: this.methodA } 中的this.methodA。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="vue-set-方法的原理"><a href="#vue-set-方法的原理" class="header-anchor">#</a> Vue.set 方法的原理</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>function set(target, key, val) {
    // 判断是否是数组
    if (Array.isArray(target)) {
        // 判断谁大谁小
        target.length = Math.max(target.length, key)
        // 执行splice
        target.splice(key, 1, val)
        return val
    }

    const ob = target.__ob__

    // 如果此对象没有不是响应式对象，直接设置并返回
    if (key in target &amp;&amp; !(key in target.prototype) || !ob) {
        target[key] = val
        return val
    }

    // 否则，新增属性，并响应式处理
    defineReactive(target, key, val)
    return val
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="vue-delete-方法的原理"><a href="#vue-delete-方法的原理" class="header-anchor">#</a> Vue.delete 方法的原理</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>function del (target, key) {
    // 判断是否为数组
    if (Array.isArray(target)) {
        // 执行splice
        target.splice(key, 1)
        return
    }

    const ob = target.__ob__

    // 对象本身就没有这个属性，直接返回
    if (!(key in target)) return


    // 否则，删除这个属性
    delete target[key]

    // 判断是否是响应式对象，不是的话，直接返回
    if (!ob) return
    // 是的话，删除后要通知视图更新
    ob.dep.notify()
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="冷门的知识点"><a href="#冷门的知识点" class="header-anchor">#</a> 冷门的知识点</h2> <h3 id="子组件改变-props-里的数据"><a href="#子组件改变-props-里的数据" class="header-anchor">#</a> 子组件改变 props 里的数据</h3> <ul><li>如果修改的是基本类型，则会报错</li> <li>改变的 props 数据是引用类型，不报错，并且父级数据会跟着变</li></ul> <h3 id="props-怎么自定义验证"><a href="#props-怎么自定义验证" class="header-anchor">#</a> props 怎么自定义验证</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>props: {
    num: {
      default: 1,
      validator: function (value) {
          // 返回值为true则验证不通过，报错
          return [
            1, 2, 3, 4, 5
          ].indexOf(value) !== -1
    }
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="watch-的-immediate-属性有什么用"><a href="#watch-的-immediate-属性有什么用" class="header-anchor">#</a> watch 的 immediate 属性有什么用</h3> <p>比如平时 created 时要请求一次数据，并且当搜索值改变，也要请求数据</p> <p>一般写法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>created(){
  this.getList()
},
watch: {
  searchInputValue(){
    this.getList()
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>使用 immediate 可以这么写，当它为 true 时，会初始执行一次</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>watch: {
  searchInputValue:{
    handler: 'getList',
    immediate: true
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="watch-监听一个对象时-如何排除某些属性的监听"><a href="#watch-监听一个对象时-如何排除某些属性的监听" class="header-anchor">#</a> watch 监听一个对象时，如何排除某些属性的监听</h3> <p>下面代码是，params 发生改变就重新请求数据，无论是 a，b，c，d 属性改变</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>data() {
    return {
      params: {
        a: 1,
        b: 2,
        c: 3,
        d: 4
      },
    };
  },
watch: {
    params: {
      deep: true,
      handler() {
        this.getList;
      },
    },
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>只想要 a，b 改变时重新请求，c，d 改变时不重新请求</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>mounted() {
    Object.keys(this.params)
      .filter((_) =&gt; ![&quot;c&quot;, &quot;d&quot;].includes(_)) // 排除对c，d属性的监听
      .forEach((_) =&gt; {
        this.$watch((vm) =&gt; vm.params[_], handler, {
          deep: true,
        });
      });
  },
data() {
    return {
      params: {
        a: 1,
        b: 2,
        c: 3,
        d: 4
      },
    };
  },
watch: {
    params: {
      deep: true,
      handler() {
        this.getList;
      },
    },
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h3 id="审查元素时发现-data-v-xxxxx"><a href="#审查元素时发现-data-v-xxxxx" class="header-anchor">#</a> 审查元素时发现 data-v-xxxxx</h3> <p>这是在标记 vue 文件中 css 时使用 scoped 标记产生的，因为要保证各文件中的 css 不相互影响，给每个 component 都做了唯一的标记，所以每引入一个 component 就会出现一个新的'data-v-xxx'标记</p> <h3 id="computed-如何实现传参"><a href="#computed-如何实现传参" class="header-anchor">#</a> computed 如何实现传参</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// html
&lt;div&gt;{{ total(3) }}

// js
computed: {
    total() {
      return function(n) {
          return n * this.num
         }
    },
  }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="vue-的-hook-的使用"><a href="#vue-的-hook-的使用" class="header-anchor">#</a> vue 的 hook 的使用</h3> <p>常用的使用定时器的方式</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default{
  data(){
    timer:null
  },
  mounted(){
      this.timer = setInterval(()=&gt;{
      //具体执行内容
      console.log('1');
    },1000);
  }
  beforeDestory(){
    clearInterval(this.timer);
    this.timer = null;
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote><p>不好的地方在于：得全局多定义一个 timer 变量，可以使用 hook 这么做：</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default{
  methods:{
    fn(){
      const timer = setInterval(()=&gt;{
        //具体执行代码
        console.log('1');
      },1000);
      this.$once('hook:beforeDestroy',()=&gt;{
        clearInterval(timer);
        timer = null;
      })
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>子组件需要在 mounted 时触发父组件的某一个函数，平时都会这么写：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//父组件
&lt;rl-child @childMounted=&quot;childMountedHandle&quot;
/&gt;
method () {
  childMountedHandle() {
  // do something...
  }
},

// 子组件
mounted () {
  this.$emit('childMounted')
},
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>使用 hook</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//父组件
&lt;rl-child @hook:mounted=&quot;childMountedHandle&quot;
/&gt;
method () {
  childMountedHandle() {
  // do something...
  }
},
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="provide-和-inject-是响应式的吗"><a href="#provide-和-inject-是响应式的吗" class="header-anchor">#</a> provide 和 inject 是响应式的吗</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 祖先组件
provide(){
    return {
   // keyName: { name: this.name }, // value 是对象才能实现响应式，也就是引用类型
      keyName: this.changeValue // 通过函数的方式也可以[注意，这里是把函数作为value，而不是this.changeValue()]
   // keyName: 'test' value 如果是基本类型，就无法实现响应式
    }
  },
data(){
  return {
	name:'张三'
}
  },
  methods: {
  	changeValue(){
  		this.name = '改变后的名字-李四'
  	}
  }

  // 后代组件
  inject:['keyName']
  create(){
	console.log(this.keyName) // 改变后的名字-李四
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="mixin-数据冲突"><a href="#mixin-数据冲突" class="header-anchor">#</a> mixin 数据冲突</h3> <ul><li>当组件 data 选项与混入 data 选项冲突时以组件 data 优先</li> <li>当组件和 mixin 同时定义生命周期选项,两个都会触发,而且 mixin 会先触发.</li> <li>组件和 mixin 同时定义相同方法,会使用组件方法,会覆盖 mixin.</li></ul> <h3 id="vue-的-el-属性和-mount-优先级"><a href="#vue-的-el-属性和-mount-优先级" class="header-anchor">#</a> Vue 的 el 属性和$mount 优先级</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>new Vue({
  router,
  store,
  el: '#app',
  render: h =&gt; h(App)
}).$mount('#ggg')

// el优先级 &gt; $mount
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="动态指令和参数"><a href="#动态指令和参数" class="header-anchor">#</a> 动态指令和参数</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;
    ...
    &lt;aButton @[someEvent]=&quot;handleSomeEvent()&quot; :[someProps]=&quot;1000&quot; /&gt;...
&lt;/template&gt;
&lt;script&gt;
  ...
  data(){
    return{
      ...
      someEvent: someCondition ? &quot;click&quot; : &quot;dbclick&quot;,
      someProps: someCondition ? &quot;num&quot; : &quot;price&quot;
    }
  },
  methods: {
    handleSomeEvent(){
      // handle some event
    }
  }
&lt;/script&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="相同的路由组件如何重新渲染"><a href="#相同的路由组件如何重新渲染" class="header-anchor">#</a> 相同的路由组件如何重新渲染</h3> <blockquote><p>经常遇到的情况是，多个路由解析为同一个 Vue 组件。问题是，Vue 出于性能原因，默认情况下共享组件将不会重新渲染，如果你尝试在使用相同组件的路由之间进行切换，则不会发生任何变化。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>const routes = [
  {
    path: &quot;/a&quot;,
    component: MyComponent
  },
  {
    path: &quot;/b&quot;,
    component: MyComponent
  },
];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如果依然想重新渲染，可以使用 key</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;
    &lt;router-view :key=&quot;$route.path&quot;&gt;&lt;/router-view&gt;
&lt;/template&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="自定义-v-model"><a href="#自定义-v-model" class="header-anchor">#</a> 自定义 v-model</h3> <p>默认情况下，v-model 是 @input 事件侦听器和 :value 属性上的语法糖。但是，可以在 Vue 组件中指定一个模型属性来定义使用什么事件和 value 属性</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default: {
  model: {
    event: 'change',
    prop: 'checked'
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="获取-data-中某一个数据的初始状态"><a href="#获取-data-中某一个数据的初始状态" class="header-anchor">#</a> 获取 data 中某一个数据的初始状态</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>data() {
    return {
      num: 10
  },
mounted() {
    this.num = 1000
  },
methods: {
    howMuch() {
        // 计算出num增加了多少，那就是1000 - 初始值
        // 可以通过this.$options.data().xxx来获取初始值
        console.log(1000 - this.$options.data().num)
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="计算变量时-methods-和-computed-哪个好"><a href="#计算变量时-methods-和-computed-哪个好" class="header-anchor">#</a> 计算变量时，methods 和 computed 哪个好</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div&gt;
    &lt;div&gt;{{howMuch1()}}&lt;/div&gt;
    &lt;div&gt;{{howMuch2()}}&lt;/div&gt;
    &lt;div&gt;{{index}}&lt;/div&gt;
&lt;/div&gt;

data: () {
    return {
         index: 0
       }
     }
methods: {
    howMuch1() {
        return this.num + this.price
    }
  }
computed() {
    howMuch2() {
        return this.num + this.price
    }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><blockquote><p>computed 会好一些，因为 computed 会有缓存。例如 index 由 0 变成 1 ，那么会触发视图更新，这时候 methods 会重新执行一次，而 computed 不会，因为 computed 依赖的两个变量 num 和 price 都没变。</p></blockquote> <h2 id="父组件如何监听子组件生命周期"><a href="#父组件如何监听子组件生命周期" class="header-anchor">#</a> 父组件如何监听子组件生命周期</h2> <p>$emit 实现</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 父组件
&lt;template&gt;
  &lt;div class=&quot;parent&quot;&gt;
    &lt;Child @mounted=&quot;doSomething&quot;/&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  methods: {
    doSomething() {
      console.log('父组件监听到子组件 mounted 钩子函数')
    }
  }
}
&lt;/script&gt;
//子组件
&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  mounted() {
    console.log('触发mounted事件...')
    this.$emit(&quot;mounted&quot;)
  }
}
&lt;/script&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>@hook 实现</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 父组件
&lt;template&gt;
  &lt;div class=&quot;parent&quot;&gt;
    &lt;Child @hook:mounted=&quot;doSomething&quot;/&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  methods: {
    doSomething() {
      console.log('父组件监听到子组件 mounted 钩子函数')
    }
  }
}
&lt;/script&gt;

//子组件
&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  mounted() {
    console.log('触发mounted事件...')
  }
}
&lt;/script&gt;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h3 id="函数式组件"><a href="#函数式组件" class="header-anchor">#</a> 函数式组件</h3> <ul><li>无状态</li> <li>无法实例化</li> <li>内部没有任何生命周期处理函数</li> <li>轻量,渲染性能高,适合只依赖于外部数据传递而变化的组件(展示组件，无逻辑和状态修改)</li> <li>在 template 标签里标明 functional</li> <li>只接受 props 值</li> <li>不需要 script 标签</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;template functional&gt;
      &lt;div&gt;
            &lt;p v-for=&quot;(item,index) in props.items&quot; :key=&quot;index&quot; @click=&quot;props.itemClick(item)&quot; /&gt;
      &lt;/div&gt;
&lt;/template&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="监听-vuex-里面的数据的变更"><a href="#监听-vuex-里面的数据的变更" class="header-anchor">#</a> 监听 Vuex 里面的数据的变更</h3> <ul><li>在 <code>.vue</code> 文件中可以直接用 <code>watch</code> 来监听</li> <li>那么如何在 <code>js</code> 或者其他文件中监听？有两种方法</li></ul> <blockquote><p>第一种：store.subscribe();subscribe 是 vuex 的一个实例方法，它通过订阅 store 的 mutation，接收一个函数作为参数，会在每个 mutation 完成后调用</p></blockquote> <ul><li>明显的缺点就是由于每个 mutation 方法完成后都会调用，所以如果只想订阅某个特定的数据需要写逻辑来判断</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>
import store from &quot;../src/store/index&quot;;

const subFun = store.subscribe((mutation, state) =&gt; {
    console.log(&quot;rd: state&quot;, state);
    console.log(&quot;rd: mutation&quot;, mutation);
    console.log(&quot;rd: mutation.type&quot;, mutation.type); // type就是我们当前执行的mutation方法的方法名
    console.log(&quot;rd: mutation.payload&quot;, mutation.payload); // payload就是我们当次执行mutation所传入的值
});


setTimeout(() =&gt; {
    subFun(); // 调用返回值可以取消订阅
}, 10000);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>第二种方法：store.watch(); 相比于上一种方法可以监听特定的数据</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>import store from &quot;../store/index&quot;;

const watchFun = store.watch(
    state =&gt; state.pathName,
    (newValue, oldValue) =&gt; {
        console.log(&quot;search string is changing&quot;);
        console.log(&quot;rd: newValue&quot;, newValue);
        console.log(&quot;rd: oldValue&quot;, oldValue);
    }
);

setTimeout(() =&gt; {
    watchFun();
}, 10000);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li>在相应的 js 文件引入 store</li> <li>调用 store 的 watch 实例方法，第一个函数参数返回一个需要监听的 state 中的值（比如我想监听 vuex 中的 pathName 的变化情况，就返回该值）</li> <li>第二个参数同 vue 的 watch，接收 2 个参数代表新旧值</li> <li>通过变量 watchFun 接收 watch 的返回值，调用该方法会停止监听</li></ul> <h2 id="vuex-如何知道-state-是通过-mutation-修改还是外部修改"><a href="#vuex-如何知道-state-是通过-mutation-修改还是外部修改" class="header-anchor">#</a> Vuex 如何知道 State 是通过 Mutation 修改还是外部修改</h2> <p>Vuex 中修改 state 唯一渠道是执行 commit 方法，底层通过执行 this._withCommit(fn)，且设置_committing 标识符为 true，才能修改 state，修改完还需要将标识符置为 false。外部修改是无法设置标识位的，所以通过 watch 监听 state 变化，来判断修改的合法性。</p> <h2 id="new-vue-后整个的流程"><a href="#new-vue-后整个的流程" class="header-anchor">#</a> new Vue 后整个的流程</h2> <ul><li>initProxy：作用域代理，拦截组件内访问其它组件的数据。</li> <li>initLifecycle：建立父子组件关系，在当前组件实例上添加一些属性和生命周期标识。如[Math Processing Error]parent,parent,refs,$children,_isMounted 等。</li> <li>initEvents：对父组件传入的事件添加监听，事件是谁创建谁监听，子组件创建事件子组件监听</li> <li>initRender：声明[Math Processing Error]slots 和 slots 和 createElement()等。</li> <li>initInjections：注入数据，初始化 inject，一般用于组件更深层次之间的通信。</li> <li>initState：重要）数据响应式：初始化状态。很多选项初始化的汇总：data,methods,props,computed 和 watch。</li> <li>initProvide：提供数据注入。</li></ul></div></div> <div class="page-edit"><div class="tags"><a href="/tags/?tag=Vue" title="标签">#Vue</a></div> <div class="last-updated"><span class="prefix">最近更新时间：</span> <span class="time">2022/09/28 16:26:36</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/eb00ff6790769/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">实现 vue 动态缓存</div></a> <a href="/pages/0b1f4ac58e0ec/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Vue 定时器销毁</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/eb00ff6790769/" class="prev">实现 vue 动态缓存</a></span> <span class="next"><a href="/pages/0b1f4ac58e0ec/">Vue 定时器销毁</a>→
      </span></p></div></div></div> <div class="theme-vdoing-wrapper article-list bg-style-5"><div class="article-title"><a href="/archives/" class="fa fa-pencil-alt">
      最近更新
    </a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><div><a href="/pages/cbeafe6f1490e/"><div>什么是 MCP</div></a></div> <div class="date"><span>2025/05/01 00:00:00</span></div></dt></dl><dl><dd>02</dd> <dt><div><a href="/pages/0b0e1b463ac7/"><div>一些小知识</div></a></div> <div class="date"><span>2022/09/01 00:00:00</span></div></dt></dl><dl><dd>03</dd> <dt><div><a href="/pages/cb81e4c5ca43f/"><div>严格判断文件上传类型</div></a></div> <div class="date"><span>2022/09/01 00:00:00</span></div></dt></dl> <div class="more-box"><a href="/archives/" class="more"><i class="fas fa-angle-double-right"></i>前往更多 ...
      </a></div></div></div> <div class="comments-wrapper" style="display:none;"><!----></div></main></div> <div class="footer-wrapper" data-v-47e9d8a4 data-v-47e9d8a4><span class="footer-reco-theme" data-v-47e9d8a4><i class="iconfont reco-github" data-v-47e9d8a4></i> <a target="blank" href="https://github.com/wudeh/wudeh.github.io" data-v-47e9d8a4>wudeh.github.io@5.0</a></span> <!----> <span class="footer-copyright" data-v-47e9d8a4><i class="iconfont reco-copyright" data-v-47e9d8a4></i> <a data-v-47e9d8a4><span data-v-47e9d8a4>wudeh</span> <span class="ml5" data-v-47e9d8a4> 2018 - 2025 </span></a></span> <span class="footer-view-site" data-v-47e9d8a4><i class="iconfont reco-eye" data-v-47e9d8a4></i> <span id="busuanzi_container_site_uv" data-v-47e9d8a4> 访客数：<span id="busuanzi_value_site_uv" class="num" data-v-47e9d8a4>-</span></span> <span id="busuanzi_container_site_pv" class="ml5" data-v-47e9d8a4> 访问量：<span id="busuanzi_value_site_pv" class="num" data-v-47e9d8a4>-</span></span></span> <!----></div> <!----></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div><!----><div></div></div></div>
    <script src="/assets/js/app.c1055618.js" defer></script><script src="/assets/js/2.fe3915ee.js" defer></script><script src="/assets/js/128.cda83341.js" defer></script><script src="/assets/js/4.439663eb.js" defer></script>
  </body>
</html>
